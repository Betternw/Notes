## 一 动态代理（代理模式）
#### 基本概念
1. 代理模式是对象的结构模式
2. 代理模式给原对象提供一个代理对象，并由代理对象控制原对象的引用
#### 静态代理
1. 静态代理：在程序运行前代理类就已经建好
2. 动态代理：程序运行后建立代理类
3. 被代理类和代理类都要同一个接口。多个代理类之间可以互相代理。因为实现了同一个接口
4. 代理类和被代理类的关系属于集合的样式。
5. 在实现的时候：
 Movable target = new TankLogProxy(new TankTimeProxy(new Tank())); 
 最内层是被代理类，最外层两个代理类顺序随意。
 6. 代理类中有被代理对象实现的接口的引用（类型还是接口类型，多态）
 7. 代理类都要实现别代理类实现的接口
 #### 基本动态代理
 1. 代理对象和目标对象的代理关系在程序运行时才确立
 2. 动态代理不需要写出代理类的名字，你要的代理对象我直接给你产生，是使用的时候生成的；
 3. 只需要调用Proxy.newProxyInstance()就可以给你产生代理类；
 4. 使用JDK的java.lang.reflect.Proxy类实现动态代理，使用静态方法newProxyInstance（）自动生成一个动态代理对象
 5. JDK 的 Proxy 实现代理，要求目标类与代理类实现相同的接口
6. ![c1f4e121265b57eaa5ae6a7d9ce72a16.png](en-resource://database/4429:1)
7. 调用过程

* （接口 对象）JDK内部的Proxy类在内部创建了一个$Proxy0的代理对象(它实现了目标对象所在接口Movable；
* （invoke handler） $Proxy0内部有InvocationHandler接口的引用，然后在$Proxy中调用了接口的invoke()方法；
* （实现类handler）将InvocationHandler接口的实现类传入了Proxy，所以我们在实现类中加入的前后逻辑就会得到执行；
![7f34fb762971fee103c4395a6432e375.png](en-resource://database/4431:1)
8. 实现

* 实现代理任意接口: 把接口类型作为参数传给MyProxy的newProxyInstance(Class inface)；
* 代理接口的所有方法: 用inface.getMethods()取出所有方法，拼接实现方法的字符串(反射)；
* 要把代理逻辑抽离，应独立出一个策略接口: MyInvocationHandler接口，并接收被代理的对象及方法作为参数invoke(Object o, Method m)；
* 而且需要把本身作为参数传给MyProxy的静态方法newProxyInstance(Class inface, MyInvocationHandler h) ；
* 而且我们具体的策略(即MyInvocationHandler的实现类)本身聚合被代理类target，以便在target的方法前后增加代理逻辑；而且其中很重要的一步: 
* 把MyInvocationHandler作为成员遍历放到$MyProxy0中，而且在每一个代理方法内部，要调用被代理对象的原始方法，
9. 当调用tank.move()的时候，就会调用invoke(this, md)，而这个md就是具体实现MyInvocationHandler接口的MyTimeProxyInvocation的方法， 也就是invoke()(在这个方法中我们在前后加了自己的逻辑)方法。


#### CGLIB动态代理
1.  JDK 的 Proxy 实现代理，要求目标类与代理类实现相同的接口。若目标类不存在接口，则无法使用该方式实现。
2.  生成目标类的子类，而子类是增强过的，这个子类对象就是代理对象。
3.  要求目标类必须能够被继承，即不能是 final 的类。
4.  **回调设计模式: 在 Java 中，类 A 调用类 B 中的某个方法 b()，并将回调对象 this 作为实参传递给了B 类，然后类 B 又在某个时候反过来调用类 A中的某个方法 a()，对于 A来说，这个 a() 方法便叫做回调方法。**

## 二 策略模式

 #### 基本概念
 1. 把每一个算法封装到具有共同接口的独立的类中，从而使得他们可以互相替换
#### 结构
1. 环境——context：持有strategy的引用
2. 抽象策略——strategy：接口或者抽象类，
3. 具体策略——包装了相关的算法或行为
## 三 观察者模式
#### 基本概念
1. 一对多的依赖关系，当一个对象的状态发生改变所有依赖于她的对象都得到通知并被自动更新。
2. 被依赖者——Subject : 登记注册register/attach、移除remove、通知notify；
3. 依赖者——Observer : 接收变化update；
#### 结构
1. 观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 Subject 类、Observer 抽象类和扩展了抽象类 Observer 的实体类。
2. 角色
● 抽象主题(Subject)角色：抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如List对象）里。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色
——一组被观察者接口
● 具体主题(ConcreteSubject)角色：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色；　——被观察者的具体实现　
● 抽象观察者(Observer)角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。——一组观察者接口　　
● 具体观察者(ConcreteObserver)角色：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象(Concrete Subject)的引用；——观察者的具体实现
#### java内置观察者实现
1. 被观察者继承自Observable类，有增加删除方法，两个更新方法，一个是推（推送给观察者），一个是拉（需要观察者自己拉去数据）
2. Java内置观察者在更新的时候，需要先调用一个setChanged()方法，标记状态已经被改变的事实。这个可以更加灵活的使用观察者模式(在调用setChanged()之前添加一些条件)；
#### 总结

* 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
* 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
* 一个对象必须通知其他对象，而并不知道这些对象是谁。
* 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。

## 四 装饰者模式
#### 基本概念
1. 对客户端透明的方式扩展对象的功能
2. 向一个现有的对象添加新的功能又不改变其结构
3. 防止因为经常使用继承方式而使子类过大

#### 结构
1. 具体组件和装饰者继承自接口或者抽象类（用父类代替描述）
2. 装饰者的方法一部分是自己的，一部分是调用接口或者抽象类的方法。
3. ![da4f758bb037d25478c328c7843adb0b.png](en-resource://database/4433:1)
4. 具体组件就是覆盖重写父类。
5. 装饰者不仅要覆盖重写，还要拿到父类的引用，因为还要控制下面的组件。
#### javaIO中使用装饰者模式
1. ![30f209280ce7d895f02a066357e82778.png](en-resource://database/4435:1)
#### 总结
1. 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。
2. 继承和装饰的区别——继承是每实现一个功能都要进行继承然后重写该方法。而装饰者是定义一个装饰者，里面定义构造方法，后面的类基于装饰者继承，继承装饰者的方法然后重新设置参数即可。
3. 
https://blog.csdn.net/qq_32101859/article/details/50733543?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase
4. 继承  被增强的对象固定的  增强的内容也是固定的
5. 装饰者模式  被增强的对象是可以切换的  增强的内容是固定的

## 四 单例模式
#### 基本概念
1. 确保一个类只有一个实例，并提供该实例的全局访问点。
2. 实现一个私有构造函数、一个私有静态变量、一个公有静态函数

#### 结构
私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。
#### 几类经典单例模式
1. 懒汉式—线程不安全
* 静态变量被延迟实例化，如果没有用到该类，就不会实例化静态变量，从而节约资源
* 多线程不安全，如果多个线程同时执行实例化语句，就会导致实例化多次、new对象的过程不是一个原子操作，当正在new的时候有其他线程进入，那么就不是单例了，被实例化多次了。

2. 懒汉式—线程安全—性能不好
* 在公有静态方法上加一把同步锁，那么在一个时间点只有一个线程可以进入方法，从而避免了多次实例化
* 但是一个线程进入后其他线程会长时间等待陷入阻塞，因此性能不好
* 建议只锁代码块不要锁方法。

3. 饿汉式—线程安全—无延迟加载
* 创建变量的时候就直接实例化
* 容易产生垃圾对象

4. 双重校验锁— 线程安全
* 使用 volatile 修饰变量，可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行
* 判断是否被实例化，如果没有被实例化，就进行加锁。加锁后，再次判断没有被实例化（并发问题，可能会有两个线程同时进入，先后被加锁，进行两次实例化，因此需要判断没有被实例化后再进行实例化），然后进行实例化
* 实例化一个变量有三个步骤——分配内存空间、初始化、将变量指向分配的内存地址。如果是在多线程中JVM会造成指令重排从而造成变量没有被成功初始化。因此使用 volatile进行修饰，保证在多线程条件下也能正常运行

5. 静态内部类实现
* 将静态变量的初始化放在内部类中，当本类加时，这个静态内部类没有被加载进内存。只有当调用公共静态方法（使用了静态内部类的调用）时才会被加载从而初始化实例，并且JVM能够保证只被初始化一次。
* 好处：延迟初始化、jvm提供了对线程安全的支持
* 这种方式是 类被装载了，变量不一定被初始化。因为内部类没有被主动使用，只有通过显式调用 newInstance() 方法时，才会显式装载内部类，从而实例化变量。

6. 枚举实现
* 自动支持序列化机制，防止多次实例化
* 该实现在多次序列化再进行反序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法
* 该实现可以防止反射攻击。在其它实现中，通过 setAccessible()(反射中的强制访问私有属性方法) 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。
#### 总结

* 一般情况下，不建议使用懒汉方式，建议使用饿汉方式。
* 只有在要明确实现 lazy loading 效果时，才会使用静态内部类方式。
* 如果涉及到反序列化创建对象时，可以尝试使用枚举方式。
* 如果有其他特殊的需求，可以考虑使用双检锁方式。

## 五 模板方法设计模式
#### 基本概念
1. 一个抽象类
* 部分逻辑以具体方法和具体构造函数实现
* 剩余逻辑用声明抽象方法，来使子类实现。不同的子类可以以不同的方式实现抽象方法，从而有不同的逻辑。
#### 结构
1. 父类；抽象
2. 模板方法：实现算法的具体步骤
3. 步骤方法——完成模板方法的每个阶段性方法
* 抽象方法——子类必须实现，个性化定义
* 最终方法——子类不能重写，所有子类要做
* 钩子方法——子类可以重写可以不重写 

## 六 迭代器
1. 顺序访问集合对象的元素，不需要知道集合对象的底层表示。
2. 如果需要容易遍历不同的集合，可以使用迭代器模式
3. 在同一个聚合上可以有多个遍历。

## 七 适配器
#### 基本概念
将一个类的接口转换成客户期望的另一个接口
#### 结构
1. 对象适配器
* 用户调用适配器转换出来的目标接口方法。适配器再调用被适配者的相关接口方法
* 用户看不到被适配者
2. 类适配器
* 适配器同时指向目标和被适配者
* 通过多重继承目标接口和被适配者类方式来实现适配。
3. 对象适配器和类适配器使用了不同的方法实现适配，对象适配器使用组合，类适配器使用继承。

## 八 简单工厂模式
1. 由一个工厂对象创建出哪一种产品类的实例
2. 创建对象时提供一个创建对象的通用接口
3. 将实例化操作放在一个单独的工厂类中，这个类来决定用哪个具体子类来实例化。
4. 客户类不需知道有哪些子类以及应当实例化哪个子类。

## 九 工厂方法模式
1. 又称为虚拟构造子模式或者多态性工厂模式
2. 定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。
3. 由大工厂（接口）的子类或者实现类来创建对象。
4. 工厂方式核心是一个抽象工厂类，是通过接口。而简单工厂模式是通过一个具体类。

## 十 抽象工厂模式
1. 工厂方法模式针对的是一个产品等级结构，抽象工厂模式需要面对多个产品等级结构。