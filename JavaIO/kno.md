## 一 概览

* 磁盘操作：File
* 字节操作：InputStream 和 OutputStream
* 字符操作：Reader 和 Writer
* 对象操作：Serializable
* 网络操作：Socket
* 新的输入/输出：NIO

## 二 磁盘操作
1. file类用于表示文件和目录的信息但是不表示文件的内容

## 三 字节操作
#### 实现文件复制
#### 装饰者模式
1. InputStream 是抽象组件；
2. FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；
3.  FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。

## 四 字符操作
#### 编码与解码
1. 编码：字符转换为字节。解码：字节组合成字符
2. GBK编码：中文两个字节英文一个字节
3. UEF-8编码：中文三个字节英文一个字节
4. UTF-16be：中文英文两个字节
#### String编码方式
1. 字符序列
2. getBytes转换为字节

#### Rreader和Writer
不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。
* InputStreamReader 实现从字节流解码成字符流；
* OutputStreamWriter 实现字符流编码成为字节流。

## 五 对象操作
#### 序列化
将一个对象转换成字节序列
* 序列化：ObjectOutputStream.writeObject()
* 反序列化：ObjectInputStream.readObject()
#### Serializable
序列化的类需要实现Serializable接口。
#### transient
1. 使一些属性不会被序列化
2. ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化

## 六 网络操作
* InetAddress：用于表示网络上的硬件资源，即 IP 地址；
* URL：统一资源定位符；
* Sockets：使用 TCP 协议实现网络通信；
* Datagram：使用 UDP 协议实现网络通信。
#### InetAddress
没有公有的构造函数，只能通过静态方法来创造实例
#### URL
可以直接从URL中读取数据
#### Socket

* Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。
* ServerSocket：服务器端类
* Socket：客户端类
* 服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。

#### Datagram

* DatagramSocket：通信类
* DatagramPacket：数据包类

## 七 NIO
新的输入输出
#### 流与块
1. IO以流的方式处理数据，NIO以块的方式处理数据
2. IO一次处理一个字节数据。输入流和输出流一次性处理一个字节数据。
3. 面向块的IO一次处理一个数据块，比流处理快。

#### 通道和缓冲区
1. 通道
* 对流的模拟，通过通道进行读取和写入数据
* 流只能一个方向，用于读或者写。
* 通道可以双向，可以读、写和读写

2. 缓冲区
* 不会直接对通道进行读写，发送给通道的数据和从通道中读取的数据都要先读到缓冲区中。
* 实质是一个数组，提供了对数据的结构化访问，跟踪系统的读写进程

#### 缓冲区状态变量

* 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，
* 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变
* 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0
* 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4
* 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。
#### 选择器
1. NIO=非阻塞IO
2. NIO实现了多路复用的Reactor模型：一个线程使用一个选择器通过轮询的方式去监听多个通道上的事件，从而让一个线程就可以处理多个事件
3. 将通道配置为非阻塞，当通道上的IO还没到达时，会轮询其他通道，找IO已经到达的通道执行，不会一直等待导致阻塞。
4. 使用一个线程来处理多个事件
5. 只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能
6. 过程
* 创建选择器
* 将通道注册到选择器上，并将通道配置为非阻塞模式
* 使用select来监听事件，一直阻塞到至少又一事件到达
* 获取到达的事件
* 事件循环：一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环
#### 内存映射文件
1. 内存映射文件IO是一种读和写文件数据的办法
2. 向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的
#### 对比
NIO 与普通 I/O 的区别主要有以下两点：

* NIO 是非阻塞的；
* NIO 面向块，I/O 面向流。