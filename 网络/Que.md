1. HTTP与HTTPS有什么区别？
* HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包
* HTTPS即HTTP下加入SSL层，超文本传输协议 (HTTP-Hypertext transfer protocol) 是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议
* 如果URL的协议是HTTP，则客户端会打开一条到服务端端口80（默认）的连接，并向其发送老的HTTP请求。 如果URL的协议是HTTPS，则客户端会打开一条到服务端端口443（默认）的连接，然后与服务器握手，以二进制格式与服务器交换一些SSL的安全参数，附上加密的 HTTP请求。
* 在写法上的区别也是前缀的不同
2. Https 请求慢的解决办法
* 不通过DNS解析，直接访问IP
* 解决head of line blocking——它的原因是队列的第一个数据包（队头）受阻而导致整列数据包受阻，使用http pipelining，确保几乎在同一时间把request发向了服务器
3. Http的request和response的协议组成
* Request组成  客户端发送一个HTTP请求到服务器  请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。
   * 请求行，用来说明请求类型get/post,要访问的资源以及所使用的HTTP版本。
   * 请求头部，用来说明服务器要使用的附加信息 ，如目的地等
   * 请求数据也叫主体，可以添加任意的其他数据
* Response组成  状态行、消息报头、空行和响应正文
   * 状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。
   * 消息报头，用来说明客户端要使用的一些附加信息
   * 响应正文，服务器返回给客户端的文本信息
4. 谈谈对http缓存的了解。
   * 强制缓存：当客户端第一次请求数据是，服务端返回了缓存的过期时间（Expires与Cache-Control），没有过期就可以继续使用缓存，否则则不适用，无需再向服务端询问。
      * Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。
      * HTTP1.1采用Cache-Control替代Expires
   * 对比缓存：当客户端第一次请求数据时，服务端会将缓存标识（Last-Modified/If-Modified-Since与Etag/If-None-Match）与数据一起返回给客户端，客户端将两者都备份到缓存中 ，再次请求数据时，客户端将上次备份的缓存 标识发送给服务端，服务端根据缓存标识进行判断，如果返回304，则表示通知客户端可以继续使用缓存。
      * 先判断资源标识码ETag，当客户端发送第一次请求时，服务端会返回当前资源的标识码，客户端再次发送，会在header里携带上次服务端返回的资源标识码，如果标识码发生改变，则说明资源已经被修改，则返回200，如果相同则说明资源没有被修改，返回 304，客户端可以继续使用缓存。
      * Last-Modified 表示资源上次修改的时间。第一次请求会返回上次的修改时间，第二次请求将资源修改时间发送，服务端接收后与当前的资源修改时间进行对比，如果自己的资源修改时间大于客户端发来的资源修改时间，则说明资源做过修改， 则返回200表示需要重新请求资源，否则返回304表示资源没有被修改，可以继续使用缓存。
5. Http长连接
   * Http1.0是短连接，HTTP1.1默认是长连接
   * 长连接实质是指的TCP连接，是一个双向的通道，它是可以保持一段时间不关闭的，
   * 长连接情况下，多个HTTP请求可以复用同一个TCP连接，这就节省了很多TCP连接建立和断开的消耗
6. Https加密原理
   * 对称加密，加密用的密钥和解密用的密钥是同一个，比较有代表性的就是 AES 加密算法；
   * 非对称加密，加密用的密钥称为公钥，解密用的密钥称为私钥，经常使用到的 RSA 加密算法就是非对称加密的
   * hash加密算法
7. 客户端如何校验 CA 证书
   *  Hash 值：证书的私钥进行加密后的值（证书的私钥不在 CA 证书中）
   * 利用证书中的公钥去解密该 Hash 值，得到 Hash-a
   * 利用证书内的签名 Hash 算法去生成一个 Hash-b 。
   * 比较 Hash-a 和 Hash-b 这两个的值，相等可以建立Https连接
8. HTTPS 中的 SSL 握手建立过程（HTTPS = HTTP + SSL，HTTPS 的加密就是在 SSL 中完成的。）
   * 客户端和服务端建立 SSL 握手，客户端通过 CA 证书来确认服务端的身份；
   * 互相传递三个随机数，之后通过这随机数来生成一个密钥；
   * 互相确认密钥，然后握手结束；
   * 数据通讯开始，都使用同一个对话密钥来加解密；
9. 有哪些响应码，分别都代表什么意思？
   * 1** 信息，服务器收到请求，需要请求者继续执行操作
   * 2** 成功，操作被成功接收并处理
   * 3** 重定向，需要进一步的操作以完成请求
   * 4** 客户端错误，请求包含语法错误或无法完成请求
   * 5** 服务器错误，服务器在处理请求的过程中发生了错误
10. 三次握手和四次握手
    * 标志位
      * ACK：连接建立后所有发送的报文ACK都必须为1
      * SYN：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。
      * FIN：当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。
    * 三次握手
      * 客户端向服务端发送请求报文，SYN=1，ACK=0，选择一个初始的序号x
      * 服务端收到连接请求报文，若同意建立连接，就SYN=1，ACK=1，确认号为x+1，同时也选择一个初始的序号y
      * 客户单受到连接确认报文，向服务端发出确认，确认号为y+1
      * 三次握手的原因：防止失效的连接请求到达服务器，让服务器错误打开连接。比如滞留的请求和等不到回应时重新发送的请求，就会使服务器打开两个链接。三次握手就会使得客户端忽略服务器之后发送的对滞留链接请求的连接确认。——————换句话说，即是为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。
    * 四次挥手
      * A 发送连接释放报文，FIN=1。
      * B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。
      * 当 B 不再需要连接时，发送连接释放报文，FIN=1。
      * A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
      * B 收到 A 的确认后释放连接。
      * “四次挥手”原因是因为tcp是全双工模式，接收到FIN时意味将没有数据再发来，但是还是可以继续发送数据。
11. TCP可靠传输原理实现（滑动窗口）。
   * 确认和重传：接收方收到报文后就会进行确认，发送方一段时间没有收到确认就会重传。
   * 数据校验。
   * 数据合理分片与排序，TCP会对数据进行分片，接收方会缓存为按序到达的数据，重新排序后再提交给应用层。
   * 流程控制：当接收方来不及接收发送的数据时，则会提示发送方降低发送的速度，防止包丢失。
   * 拥塞控制：当网络发生拥塞时，减少数据的发送。
12. TCP和UDP的区别
   * 基于连接与无连接；
   * 对系统资源的要求（TCP较多，UDP少）；
   * UDP程序结构较简单；
   * 流模式与数据报模式 ；
   * TCP保证数据正确性，UDP可能丢包；
   * TCP保证数据顺序，UDP不保证。
13. socket断线重连怎么实现，心跳机制又是怎样实现？
   * 套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元，操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口，应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。
   * 建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。
   * 创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。
   * Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网 络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数 据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求， 不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。
   * socket断线重连实现：正常连接断开客户端会给服务端发送一个fin包，服务端收到fin包后才会知道连接断开。 而断网断电时客户端无法发送fin包给服务端，所以服务端没办法检测到客户端已经短线。 为了缓解这个问题，服务端需要有个心跳逻辑，就是服务端检测到某个客户端多久没发送任何数据过来就认为客户端已经断开， 这需要客户端定时向服务端发送心跳数据维持连接。
   * 心跳机制实现：应用层协议大多都有HeartBeat机制，通常是客户端每隔一小段时间向服务器发送一个数据包，通知服务器自己仍然在线。并传输一些可能必要的数据。使用心跳包的典型协议是IM，比如QQ/MSN/飞信等协议
14. Cookie和Seession的作用和原理
   * Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。session和cookie的作用有点类似，都是为了存储用户相关的信息。不同的是，cookie是存储在本地浏览器，而session存储在服务器。存储在服务器的数据会更加的安全，不容易被窃取。但存储在服务器也有一定的弊端，就是会占用服务器的资源，
   * Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。在网站中，http请求是无状态的。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。cookie的出现就是为了解决这个问题，第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。cookie存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用cookie只能存储一些小量的数据。
   * 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.具体到Web中的Session指的就是用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。当客户端访问服务器时，服务器根据需求设置Session，将会话信息保存在服务器上，同时将标示Session的SessionId传递给客户端浏览器，浏览器将这个SessionId保存在内存中，以后浏览器每次请求都会额外加上这个参数值，服务器会根据这个SessionId，就能取得客户端的数据信息。
   * 通过cookie存储一个session_id，然后具体的数据则是保存在session中。如果用户已经登录，则服务器会在cookie中保存一个session_id，下次再次请求的时候，会把该session_id携带上来，服务器根据session_id在session库中获取用户的session数据。就能知道该用户到底是谁，以及之前保存的一些状态信息。
15. 浏览器输入地址到返回结果发生了什么？
* DNS解析——网址转换为ip地址（每个ip地址是一台计算机）
   * DNS解析：查找www.baidu.com：本地域名查询ip地址——com顶级域名服务器查询——baidu.com域名服务器，得到ip地址并缓存到本地供下次查询使用。
   * DNS优化
     * DNS缓存：存在多级缓存
     * DNS负载均衡：DNS返回一个合适的机器的离用户最近的IP地址给用户，
* TCP连接——使用HTTP协议
* 发送HTTP请求——发送到服务器指定端口（HTTP 80/8080 HTTPS 协议443） 常用方法是get和post、put
* 服务器处理请求并返回HTTP报文——后端从端口收到TCP报文（socket），对http协议进行解析，按照报文格式进一步封装成HTTP Request对象，比如tomcat等
* 浏览器解析渲染页面——浏览器收到Html css js文件后渲染呈现
* 连接结束
16. 如何尽快的加载资源（网络优化）？
* 从网络中加载的资源就不从网络中加载，当我们合理使用缓存，将资源放在浏览器端，这是最快的方式。如果资源必须从网络中加载，则要考虑缩短连接时间，即DNS优化部分;减少响应内容大小，即对内容进行压缩。另一方面，如果加载的资源数比较少的话，也可以快速的响应用户。



