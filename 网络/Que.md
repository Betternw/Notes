1. HTTP与HTTPS有什么区别？
* HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包
* HTTPS即HTTP下加入SSL层，超文本传输协议 (HTTP-Hypertext transfer protocol) 是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议
* 如果URL的协议是HTTP，则客户端会打开一条到服务端端口80（默认）的连接，并向其发送老的HTTP请求。 如果URL的协议是HTTPS，则客户端会打开一条到服务端端口443（默认）的连接，然后与服务器握手，以二进制格式与服务器交换一些SSL的安全参数，附上加密的 HTTP请求。
* 在写法上的区别也是前缀的不同
2. Https 请求慢的解决办法
* 不通过DNS解析，直接访问IP
* 解决head of line blocking——它的原因是队列的第一个数据包（队头）受阻而导致整列数据包受阻，使用http pipelining，确保几乎在同一时间把request发向了服务器
3. Http的request和response的协议组成
* Request组成  客户端发送一个HTTP请求到服务器  请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。
   * 请求行，用来说明请求类型get/post,要访问的资源以及所使用的HTTP版本。
   * 请求头部，用来说明服务器要使用的附加信息 ，如目的地等
   * 请求数据也叫主体，可以添加任意的其他数据
* Response组成  状态行、消息报头、空行和响应正文
   * 状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。
   * 消息报头，用来说明客户端要使用的一些附加信息
   * 响应正文，服务器返回给客户端的文本信息
4. 谈谈对http缓存的了解。
   * 强制缓存：当客户端第一次请求数据是，服务端返回了缓存的过期时间（Expires与Cache-Control），没有过期就可以继续使用缓存，否则则不适用，无需再向服务端询问。
      * Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。
      * HTTP1.1采用Cache-Control替代Expires
   * 对比缓存：当客户端第一次请求数据时，服务端会将缓存标识（Last-Modified/If-Modified-Since与Etag/If-None-Match）与数据一起返回给客户端，客户端将两者都备份到缓存中 ，再次请求数据时，客户端将上次备份的缓存 标识发送给服务端，服务端根据缓存标识进行判断，如果返回304，则表示通知客户端可以继续使用缓存。
      * 先判断资源标识码ETag，当客户端发送第一次请求时，服务端会返回当前资源的标识码，客户端再次发送，会在header里携带上次服务端返回的资源标识码，如果标识码发生改变，则说明资源已经被修改，则返回200，如果相同则说明资源没有被修改，返回 304，客户端可以继续使用缓存。
      * Last-Modified 表示资源上次修改的时间。第一次请求会返回上次的修改时间，第二次请求将资源修改时间发送，服务端接收后与当前的资源修改时间进行对比，如果自己的资源修改时间大于客户端发来的资源修改时间，则说明资源做过修改， 则返回200表示需要重新请求资源，否则返回304表示资源没有被修改，可以继续使用缓存。
5. Http长连接
   * Http1.0是短连接，HTTP1.1默认是长连接
   * 长连接实质是指的TCP连接，是一个双向的通道，它是可以保持一段时间不关闭的，
   * 长连接情况下，多个HTTP请求可以复用同一个TCP连接，这就节省了很多TCP连接建立和断开的消耗
6. Https加密原理
   * 对称加密，加密用的密钥和解密用的密钥是同一个，比较有代表性的就是 AES 加密算法；
     * 存在问题：密钥传递的安全性，在网络上面的通信双方都是陌生人，无法识别身份，密钥要通过网络传输时很有可能被窃取。
   * 非对称加密，加密用的密钥称为公钥，解密用的密钥称为私钥，经常使用到的 RSA 加密算法就是非对称加密的
     * 即使公钥被窃取，依然无法解密消息内容。存在问题 -> 速度慢，消耗大；公钥被公开，如果回发私钥加密的信息，任何持有公钥的人都可以解密。
   * hash加密算法
7. 客户端如何校验 CA 证书
   *  Hash 值：证书的私钥进行加密后的值（证书的私钥不在 CA 证书中）
   * 利用证书中的公钥去解密该 Hash 值，得到 Hash-a
   * 利用证书内的签名 Hash 算法去生成一个 Hash-b 。
   * 比较 Hash-a 和 Hash-b 这两个的值，相等可以建立Https连接
8. HTTPS 中的 SSL 握手建立过程（HTTPS = HTTP + SSL，HTTPS 的加密就是在 SSL 中完成的。）
   * 客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密，进行握手协商。
   * 双方协商生成对话密钥(握手产生的三个随机数)。
   * 双方采用对话密钥进行加密通信。
   * ssl加密
     * 对称密钥加密：加密和解密使用同一密钥。
     * 非对称密钥加密（公开密钥加密）：加密和解密使用不同的密钥。公开密钥谁都可以获得，发送方获得接收方的公开密钥进行加密，接收方收到通信内容后使用私有密钥进行解密——公开密钥加密，私有密钥解密
     * HTTPS采用混合加密机制：使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，获取到Secret Key 后，再使用对称密钥加密方式进行通信
9. Https的安全性：对称加密通信 + 非对称加密交换密钥 + CA 认证身份 + 证书锁锁定证书指纹 
10. Https的连接过程
   * 客户端发送请求到服务端
   * 服务端返回公钥和证书到客户端
   * 客户端验证证书安全性，生成随机数用公钥进行加密，发送给服务端
   * 服务端收到后用私钥解密得到随机数，用随机数当做私钥对传输数据进行对称加密
   * 客户端收到加密后的数据后用随机值（私钥）进行解密，并解析数据
11. 为什么是三个随机数
   * 三次传输数据每次随机数不同，这样生成的密钥才会不同。
   * SSL 协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。
12. 有哪些响应码，分别都代表什么意思？
   * 1** 信息，服务器收到请求，需要请求者继续执行操作
   * 2** 成功，操作被成功接收并处理
   * 3** 重定向，需要进一步的操作以完成请求
   * 4** 客户端错误，请求包含语法错误或无法完成请求
   * 5** 服务器错误，服务器在处理请求的过程中发生了错误
12. 三次握手和四次握手
    * 标志位
      * ACK：连接建立后所有发送的报文ACK都必须为1
      * SYN：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。
      * FIN：当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。
    * 三次握手
      * 客户端向服务端发送请求报文，SYN=1，ACK=0，选择一个初始的序号x
      * 服务端收到连接请求报文，若同意建立连接，就SYN=1，ACK=1，确认号为x+1，同时也选择一个初始的序号y
      * 客户单受到连接确认报文，向服务端发出确认，确认号为y+1
      * 三次握手的原因：防止失效的连接请求到达服务器，让服务器错误打开连接。比如滞留的请求和等不到回应时重新发送的请求，就会使服务器打开两个链接。三次握手就会使得客户端忽略服务器之后发送的对滞留链接请求的连接确认。——————换句话说，即是为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。
    * 四次挥手
      * A 发送连接释放报文，FIN=1。
      * B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。
      * 当 B 不再需要连接时，发送连接释放报文，FIN=1。
      * A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
      * B 收到 A 的确认后释放连接。
      * “四次挥手”原因是因为tcp是全双工模式，接收到FIN时意味将没有数据再发来，但是还是可以继续发送数据。
13. TCP可靠传输原理实现（滑动窗口）。
   * 确认和重传：接收方收到报文后就会进行确认，发送方一段时间没有收到确认就会重传。
   * 数据校验。
   * 数据合理分片与排序，TCP会对数据进行分片，接收方会缓存为按序到达的数据，重新排序后再提交给应用层。
   * 流程控制：当接收方来不及接收发送的数据时，则会提示发送方降低发送的速度，防止包丢失。
   * 拥塞控制：当网络发生拥塞时，减少数据的发送。
12. TCP和UDP的区别
   * 基于连接与无连接；
   * 对系统资源的要求（TCP较多，UDP少）；
   * UDP程序结构较简单；
   * 流模式与数据报模式 ；
   * TCP保证数据正确性，UDP可能丢包；
   * TCP保证数据顺序，UDP不保证。
13. socket断线重连怎么实现，心跳机制又是怎样实现？
   * 套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元，操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口，应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。
   * 建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。
   * 创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。
   * Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网 络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数 据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求， 不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。
   * socket断线重连实现：正常连接断开客户端会给服务端发送一个fin包，服务端收到fin包后才会知道连接断开。 而断网断电时客户端无法发送fin包给服务端，所以服务端没办法检测到客户端已经短线。 为了缓解这个问题，服务端需要有个心跳逻辑，就是服务端检测到某个客户端多久没发送任何数据过来就认为客户端已经断开， 这需要客户端定时向服务端发送心跳数据维持连接。
   * 心跳机制实现：应用层协议大多都有HeartBeat机制，通常是客户端每隔一小段时间向服务器发送一个数据包，通知服务器自己仍然在线。并传输一些可能必要的数据。使用心跳包的典型协议是IM，比如QQ/MSN/飞信等协议
14. Cookie和Seession的作用和原理
   * Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。session和cookie的作用有点类似，都是为了存储用户相关的信息。不同的是，cookie是存储在本地浏览器，而session存储在服务器。存储在服务器的数据会更加的安全，不容易被窃取。但存储在服务器也有一定的弊端，就是会占用服务器的资源，
   * Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。在网站中，http请求是无状态的。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。cookie的出现就是为了解决这个问题，第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。cookie存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用cookie只能存储一些小量的数据。
   * 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.具体到Web中的Session指的就是用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。当客户端访问服务器时，服务器根据需求设置Session，将会话信息保存在服务器上，同时将标示Session的SessionId传递给客户端浏览器，浏览器将这个SessionId保存在内存中，以后浏览器每次请求都会额外加上这个参数值，服务器会根据这个SessionId，就能取得客户端的数据信息。
   * 通过cookie存储一个session_id，然后具体的数据则是保存在session中。如果用户已经登录，则服务器会在cookie中保存一个session_id，下次再次请求的时候，会把该session_id携带上来，服务器根据session_id在session库中获取用户的session数据。就能知道该用户到底是谁，以及之前保存的一些状态信息。
15. 浏览器输入地址到返回结果发生了什么？
* DNS解析——网址转换为ip地址（每个ip地址是一台计算机）
   * DNS解析：查找www.baidu.com：本地域名查询ip地址——com顶级域名服务器查询——baidu.com域名服务器，得到ip地址并缓存到本地供下次查询使用。
   * DNS优化
     * DNS缓存：存在多级缓存
     * DNS负载均衡：DNS返回一个合适的机器的离用户最近的IP地址给用户，
* TCP连接——使用HTTP协议
* 发送HTTP请求——发送到服务器指定端口（HTTP 80/8080 HTTPS 协议443） 常用方法是get和post、put
* 服务器处理请求并返回HTTP报文——后端从端口收到TCP报文（socket），对http协议进行解析，按照报文格式进一步封装成HTTP Request对象，比如tomcat等
* 浏览器解析渲染页面——浏览器收到Html css js文件后渲染呈现
* 连接结束
16. 如何尽快的加载资源（网络优化）？
* 从网络中加载的资源就不从网络中加载，当我们合理使用缓存，将资源放在浏览器端，这是最快的方式。如果资源必须从网络中加载，则要考虑缩短连接时间，即DNS优化部分;减少响应内容大小，即对内容进行压缩。另一方面，如果加载的资源数比较少的话，也可以快速的响应用户。
17. TCP和UDP区别
   * UDP：无连接、不可靠传输、支持一对一，一对多，多对一和多对多交互通信，面型报文，首部开销小，适用于实时应用
   * TCP：面向连接、可靠传输拥塞控制和流量控制、一对一通信、面向字节流、
   * TCP如何保证可靠传输：校（首部和数据的校验和不发生改变）、序（对每个包进行编号，排序有序的发送）、重（丢弃重复的数据）、流（流量控制、滑动窗口）、拥（拥塞减少数据的发送）
18. 网络结构
* 一般采用中和了OSI和TCP/IP体系的五层的协议体系。
   * 应用层：为应用程序提供交互服务。包含协议有DNS、HTTP、SMTP等。
   * 运输层：向主机进程提供通用的数据传输服务。主要包括TCP(传输控制协议)和UDP(用户数据协议)。
   * 网络层：选择合适的路由和交换结点，确保数据及时传送。主要包括IP协议。
   * 数据链路层：将网络层传下来的IP数据包组装成帧，并再相邻节点的链路上传送帧。
   * 物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和通信手段的差异。
* TCP/IP协议簇
   * 互联网协议套件IPS是一个网络通讯模型，以及一整个网络传输协议家族，是网际网络的基础通讯架构。因为TCP和IP是最早制定的标准，所以又被称为TCP/IP协议簇。
   * 应用协议：HTTP、SMTP、FTP、TELNET；
   * 传输协议：TCP、UDP；
   * 网际协议：IP、ICMP、ARP；
   * 路由控制协议：RIP、OSPF、BGP。
19. TCP
* 首部格式
   * 源端口号
   * 目的端口号
   * 序号：对字节流编号。
   * 确认号：期望收到的下一个报文段序号。eg.B收到A的序号201，长度100，则B发给A的确认报文段的确认号为301。
   * 数据偏移：指首部的长度。
   * 标志位：总共有6个。
      * 确认ACK：当ACK=1时，确认号字段有效，否则无效。连接建立后，ACK都为1。
      * 同步SYN：建立连接时同步序号。当SYN=1 ACK=0时，为请求连接报文，SYN=1 ACK=1为建立连接的响应报文。
      * 终止FIN：释放连接。当FIN=1时，为此报文端的发送方数据发送完毕，请求关闭连接。
      * 重置RST
      * 数据传输PSH：有报文需要传递给应用层
      * 紧急指针URG：设置紧急指针有效
   * 窗口：作为接收方让发送方设置其发送窗口的依据。
   * 注：确认方ack = 发送方seq + 1
* 三次握手
   * 流程
      * 客户端—发送连接请求报文SYN=1，ACK=0，初始序号随机seq=x—服务端
      * 服务端—发送连接确认报文SYN=1，ACK=1，确认号ack=x+1，初始序号随机seq=y—客户端
      * 客户端—发出连接确认报文，ACK=1，确认号ack=y+1，序号seq=x+1
   * 为什么要三次握手
      * 确保可靠的通信通道，让双方都确认对方和自己的接收和发送功能是正常的。
      * 第一次握手，Server知道Client的发送能力和自己的接收能力是正常的。
      * 第二次握手，Client知道Server的发送和接收能力和自己的发送和接收能力是正常的，但是Server还不知道我的接收和他的发送能力正常与否。
      * 第三次握手，Client回馈，让Server知道自己的发送能力和Client的接收能力正常。
   * 为什么不是两次握手
         * 没有最后一次客户端的确认，会导致服务端可能接受到的是延迟的客户端消息发送，而可能客户端已经重发过了，之前的请求已经失效。
         * 防止失效连接请求报文段被服务端接收，避免浪费服务端资源。
         * 例子：因为网络拥堵客户端重发连接请求进行通信，结束后释放连接。此时原来失效的请求到达服务端，直接进入 establish 状态，等待客户端的请求数据。但客户端早就关闭了，服务端会一直等待直到进行下面的操作。
* 检测连接失效
   * 通过保活计时器和探测报文实现。
   * TCP设有保活计时器，Server每收到一次Client的请求，就复位计时器，通常是设置为2小时；
   * 若2小时内还没有收到Client的任何数据，Server每隔75s发送一个探测报文段，若连发10个探测报文仍没反应，Server认为Client故障，关闭连接。
* 四次挥手
   * 流程
      * A 发送连接释放报文，FIN=1。
      * B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。
      * 当 B 不再需要连接时，发送连接释放报文，FIN=1。
      * A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
      * B 收到 A 的确认后释放连接。
   * 为什么要四次挥手
     * Server端可能还有数据没有发送完毕。Client发出连接释放通知，Server确认收到后，Client就进入半关闭状态（只收消息不发消息），Server把未发完的数据发送完毕后，发送连接释放通知，Client确认后就关闭连接。
   * 为什么Client要等待2msl
     * 2msl是在client收到server的确认释放连接后，发送确认报文后等待2msl后，再释放。
     * 确保server收到了client的确认报文。防止ack报文丢失，Server再次发送Fin报文，一来一回最长时间就是2MSL(Maximum Segment Lifetime最大报文生存周期)。
* 可靠传输
  * 超时重传
    * 若一个已经发送的报文段在超时时间内没有收到确认，就重传这个报文段。超时时间RTO略大于加权往返时间RTTs。往返时间RTT指一个报文段从发送再到接收到确认所经过的时间。
  * ARQ自动重传
    * ARQ包括停止等待ARQ和连续ARQ。
    * 停止等待ARQ协议：基本原理是每发完一个分组就停止发送，等待对方确认，收到确认后再发送下一组，没有收到就重传。优点是简单，缺点是信道利用率低。总结：发完一个就停止，确认后再发下一个、
    * 连续ARQ协议：维持一个发送窗口，在窗口内的分组可以连续发送不用等待确认，接收方对到达的最后一个分组发送确认。优点是信道利用率高，缺点是发送方无法知道接收方正确收到的分组信息，重传需要回退N。总结：不用确认就能发，对last one确认，失败需要回退N。 流水线技术
    * 选择重传协议：若发送方接收重复确认，就判断下一个报文段丢失，就立即重传下一报文段。
  * 滑动窗口
    * 发送方的滑动窗口大小根据接收方来设置，接收方通过tcp告知自己的滑动窗口大小。
    * 发送窗口的最左部为已发送但未收到确认的第一个字节，
    * 接收窗口的最左部为已发送确认并交付主机。
    * 接收窗口只对最后一个按序到达的字节进行确认。如：收到31,34,35，没收到32，33.只对31进行确认。
  * 流量控制
    * 流量控制是为控制发送方发送速率，保证接收方能及时接收。通过滑动窗口实现流量控制。
  * 拥塞控制（1——加倍——+1——减半；快重传；快恢复）
    * 拥塞控制是为了防止过多数据注入网络，导致网络过载。TCP的拥塞控制采用四个算法实现：慢开始、拥塞避免、快重传、快恢复。
    * 发送方维护一个拥塞窗口(cwnd)的状态变量。
    * 慢开始：cwnd初始值为1，每个轮次cwnd加倍
    * 拥塞避免：慢开始门限ssthresh，当cwnd>ssthresh时，进入拥塞避免，让cwnd每个轮次+1。出现超时，就令ssthresh = cwnd/2，重新进行慢开始。
    * 快重传：接收方只对最后一个收到的有序报文段进行确认，若发送方介绍重复确认，就判断下一个报文段丢失，执行快重传，即立即重传下一报文段。
    * 快恢复：若丢失个别报文段，执行快恢复，令ssthresh = cwnd/2, cwnd = ssthresh，直接进入拥塞避免。
    * 为啥要慢开始
      * 最初的TCP在连接建立成功后便会向网络中发送大尺寸的数据包，假如网络出现问题，大数据包会积攒在路由器上，路由器缓存空间耗尽，从而发生拥塞。
      * 现在的TCP规定了，新建立的连接只能从一个小尺寸的包开始发送，在发送和数据被对方确认的过程中去计算对方的接收速度，来逐步增加每次发送的数据量，最后到达一个稳定的值，进入高速传输阶段，以避免上述现象的发生。这个策略就是慢启动。
      * 所以慢启动会导致Client和Server要经过几百毫秒才能开始高速通信，对于大型服务影响不显著，因为能均分消化，对于小文件的传输不利。
* 基于TCP/UDP的协议
   * 基于TCP
     * HTTP超文本传输协议，主要用于普通浏览。
     * HTTPS安全超文本传输协议，HTTP协议的安全版本。
     * FTP文件传输协议，用于文件传输。端口20/21。
     * POP3邮局协议，从服务器中检索获取邮件。客户端行为不会影响服务器中邮件状态。
     * SMTP简单邮件传输协议，用来发送和中转电子邮件。
     * TELNET远程登录，通过一个终端登陆到网络。
     * SSH，用于加密安全登陆。
     * IMAP，保持Client和Server上邮件的同步，让用户随时都能访问服务器的邮件，客户端行为能影响服务器邮件的状态。
   * 基于UDP
     * BOOTP启动协议，应用于无盘设备。
     * NTP网络时间协议，用于网络同步。
     * DHCP动态主机配置协议，动态配置IP地址。
   * 同时都有
     * DNS域名服务，用于完成地址查找，邮件转发等工作。端口53。
* TCP/IP四层
  * 应用层：为应用进程提供服务
  * 运输层
  * 网络层：进行网络连接的建立和终止以及IP地址的寻找等功能。
  * 网络接口层：网络接口层兼并了物理层和数据链路层，网络接口层既是传输数据的物理媒介，也可以为网络层提供一条准确无误的线路。
1.  UDP
* UDP首部格式
   * UDP首部只有8个字节，包括源端口、目的端口、长度、检验和。
* TCP和UDP区别
   * TCP：面向连接的可靠交付，以字节流传输，效率低，耗费资源多，适用于对通信数据严格的场景，如文件传输。首部20-60字节。
   * UDP：无连接的尽最大努力交付，以数据报文段传输，速度快，耗费资源少，适用于对通信速度要求高的场景，如在线视频。首部8个字节。
* 为什么视频用UDP
   * TCP需要三次握手，建立会话需要时间；
   * TCP在网络拥塞时，会调整滑动窗口大小，影响传输速度；
   * UDP无连接，没有拥塞控制，会以恒定速度发送数据，缺点是造成丢包，优点是实时性好。
* UDP处理丢包
  * 发生丢包，就立即发送冗余包，尽快恢复数据；
  * 建立长期参考帧，解决连贯性问题；
  * 发生网络抖动，降低码率，保证传输数据小于网络带宽。
21. HTTP
* HTTP超文本传输协议，是一种无状态的面向连接的协议，规定了Client和Server间通信的格式。
* 长连接和短连接
   * HTTP协议的长连接和短连接，实质上就是TCP协议的长连接和短连接。
   * HTTP/1.0默认使用短连接，即Client和Server每进行一次HTTP操作，就建立一次连接，任务结束就中断。
   * HTTP/1.1起默认使用长连接，网页打开后，Client和Server间传输数据的TCP连接不会关闭，之后再进行访问就直接用已建立的连接。
* 如何理解无状态
  * HTTP的无状态，指协议对于事务处理没有记忆能力，不对通信状态进行保存，服务器无法判断用户身份。即打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。
* 如何保持会话状态
  * Cookie和Session保存会话状态，用Session来唯一标识用户，用Cookie当作用户通行证。
  * 服务端收到请求处理后生成一个SessionId，将SessionId存入Cookie返回给客户端，将Session内容存储在服务器上。
  * 下一次请求时，客户端带着Cookie来请求服务器，服务端从Cookie中取出SessionId，从而实现用户会话状态的保持。
  * 第一次登陆后，服务端生成Token给客户端，客户端之后带着Token请求数据即可。减轻服务器的压力，减少频繁查询数据库。
* Cookie，Session和Token
  * 都是用来跟踪用户身份的会话方式。
  * Cookie：在客户端保存用户信息，安全性较差，并且浏览器会限制cookie数量。eg. 保存登录用户信息，下次自动填写登录信息；登录网 站后访问其他页面就不用登录。
  * Session：在服务端记录用户状态，安全性较高，但占用服务器性能。eg. 购物车添加物品，根据Session知道用户的购物车。
  * Token：在客户端保存认证授权状态，适合前后端分离的项目(处于不同服务器)。
* Get和Post区别
  * HTTP定义了四种基本方法：Get、Post、Put和Delete。
  * Get用来从服务器 查询 获取资源，Post用来 更新/创建 服务器资源；
  * Get将参数拼接在URL后，明文显示，Post用于提交表单，非明文显示；
  * Get有长度限制，Post没有。
  * GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中，因此提交时，get不如post安全
  * Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在html的header中内提交。
* HTTP和HTTPS的区别
  * HTTP超文本传输协议，明文传输。默认80端口。安全性低。
  * HTTPS=HTTP+SSL/TLS，加密传输。默认443端口。消耗资源多，需要证书。
* SSL安全套接字层协议
   * 利用数据加密，身份验证和消息完整性检测，保证数据传输完整性。建立在 TCP 和 应用层之间。
   * 身份验证机制：数字签名。
   * 数据加密：对称密钥算法。
   * 完整性验证：MAC算法。
   * 利用非对称加密算法加密密钥保证第三方无法获得密钥。
   * 使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率
   * 流程：
     * 客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密，进行握手协商。
     * 双方协商生成对话密钥(握手产生的三个随机数)。
     * 双方采用对话密钥进行加密通信。
* HTTP1.0，1.1和2.0的区别
  * HTTP1.0：默认短连接，每次请求都建立TCP连接，服务完成立即断开，开销大；错误状态响应码少；不支持断点续传。
  * HTTP1.1：默认长连接；增加了响应码和缓存策略；支持传输部分数据。
  * HTTP2.0：引入多路复用，通过一个TCP就能传输所有请求，提高性能。
* 常见的HTTP 状态码
   * 1xx：临时响应/请求正在处理。2xx：成功。3xx：重定向。4xx：请求错误。5xx：服务器错误。
   * 200：成功。
   * 302：临时重定向到指定网页。
   * 304：not modified服务器允许访问资源，但请求未满足条件。
   * 400：bad request，请求报文存在语法错误。
   * 401：unauthorized未授权，要求身份验证。
   * 403：forbidden禁止，服务器拒绝访问。
   * 404：not found未找到，服务器找不到请求的网页。
   * 405：方法禁用，Post当成Get。
   * 502：服务器网关错误。
   * 503：service unavailable，服务器超负荷或停机维护。
   * 504：网关超时，nginx请求超时。
* HTTP连接过程
  * 浏览器从URL解析出服务器的主机名
  * 浏览器将主机名转换成服务器的ip地址（DNS）
  * 浏览器从URL解析出主机的端口号
  * 建立TVP连接
  * 发送HTTP请求报文
  * 服务器响应response报文
  * 关闭连接
22.  IP协议
* IP数据报格式
  * 版本：有4(IPv4)和6(IPv6)两个值；
  * 首部长度：最大值为15，最小值为5(固定部分长度为20字节)；
  * 区分服务：一般不用，用来获得不同的服务；
  * 总长度：首部长度 + 数据部分长度；
  * 标识：若长度过长而分片，相同数据报的不同分片就有相同的标识符；
  * 片偏移：8字节，用于分片情况。
  * 生存时间：TTL，为了防止数据报一直滞留在网络中不消亡；
  * 协议：指明携带的数据交给传输层的哪个协议处理；
  * 首部检验和：数据报每经过一个路由器，都要重新计算检验和；
* IP地址编制方式
   * 分类
     * IP地址 = {<网络号>，<主机号>}。不同分类由不同的网络长度。
   * 子网划分
     * 把主机号字段的一部分作为子网号。IP地址 = {<网络号>,<子网号>,<主机号>}。使用子网，必须要配置子网掩码。
     * eg. B类地址，默认子网掩码为255.255.0.0，若子类占2个字节，则子网掩码为255.255.192.0(8个1 8个1 11000000 8个0)。
   * 无分类
     * 无分类编址CIDR消除了分类和子网的概念。IP地址 = {<网络前缀号>,<主机号>}。一个CIDR能表示原来多个网络，且只要一个路由项，这种使用网络前缀减少路由表项的方式就是构成超网。
     * eg. 128.14.35.7/20表示前20位为网络前缀。
23. 应用层其他协议
* FTP
   * FTP 文件传输协议，使用TCP连接，通过控制连接和数据连接来传送文件。FTP 需要保存用户状态，记录用户在远程的操作。
   * 控制连接：独立的tcp传输，传输 FTP 命令。端口号21；
   * 数据连接：传送文件数据，端口号20。
   * 控制连接贯穿始终，数据连接随着一个文件的传输而建立，随着传输结束而关闭。
* 电子邮件协议
   * 电子邮件系统
     * 由 用户代理、邮件服务器和SMTP 三个核心组成。
     * 发送方通过用户代理将邮件传送到发送方的邮件服务器；
     * 再传输到接收方的邮件服务器；
     * 之后被转发到接收方的邮箱里；
     * 接收方从邮件服务器里获取自己的邮件时需要通过邮件服务器的验证。
   * SMTP
     * SMTP 简单邮件传输协议，是用来在邮件服务器间发送邮件报文的协议。端口25。
     * SMTP 理解为 Push 协议，即是客户将信息推到服务器端，且 SMTP 只能用 ASCII 码，并将所有报文对象都放在一个报文中。
   * POP3
     * POP3 负责从邮件服务器中检索邮件，让用户读取。但无法解决客户端和服务端的邮件状态同步。
     * 比如：用户在一台设备查看邮件后，邮件在服务端删除，其他设备无法查看。
   * IMAP
     * IMAP 能保持 Client 和 Server 上邮件的同步，让用户随时都能访问服务器的邮件。
     * 原理是将邮件和收件人的INBOX 或 文件夹关联。
* DNS
  * DNS 域名系统由一个分布式数据库和一个主机查询应用层协议组成。
  * 能提供主机名和IP地址间的相互转换。端口号53，使用UDP传输。
  * DNS 采用分布式的设计方案，服务器分为根服务器、顶级服务器、二级服务器、以此类推。查询分为递归查询和迭代查询，
  * 除了请求主机到本地 DNS 服务器是递归，其他都是迭代。
* DHCP动态主机配置协议
  * DHCP提供动态配置主机信息的功能，如IP地址、子网掩码、网关地址等。
  * Client通过UDP发送Discover报文，被广播到子网的所有主机上(不在同个子网则中继代理)
  * Server收到报文，发送Offer报文给Client，其中包括Client需要的信息
  * Client可能收到多个Offer报文，选择某个Server的报文后，发送Request报文给对应Server
  * Server收到后，发送Ack报文，表示Client能使用其发送的信息
  * 理解为：客户端海投简历，拿了多个offer，最后只会跟一家签约。
* TELNET远程登录协议
  * TELNET用于登录远程主机并将远程主机上的输出返回。
24. 网络层其余协议
* ARP地址解析协议
  * ARP地址解析协议的作用就是由IP地址获得MAC地址。
  * 实现：每个主机都有一个ARP缓存表，存着局域网内主机和路由器的IP地址到MAC地址的映射表。
  * 若主机A知道主机B的IP地址，但ARP缓存中没有该地址的MAC映射；
  * 主机A通过广播发送ARP请求；
  * 主机B收到请求后，发送ARP响应给主机A告知MAC地址；
  * 主机A向自己的ARP缓存中写入主机B的IP地址到MAC地址的映射。
* ICMP网际控制报文协议
   * ICMP网际控制报文协议，是为了更有效地转发IP数据报和提高交付能力，被封装在IP数据报中。分为差错报告报文和询问报文。
   * ICMP应用
     * Ping
       * 用来测试两台主机间的连通性。
       * 原理是向目的主机发送ICMP Echo请求报文，目的主机收到后发送ICMP Echo回答报文。
       * Ping根据时间计算往返时间，根据成功的响应次数计算丢包率。
     * Traceroute
       * 用来跟踪一个分组从源点到终点的路径。
       * 原理是IP数据报封装的是无法交付UDP，设置TTL，每经过一个路由器TTL–，到达目的主机时向源主机发送ICMP终点不可达差错报文。源主机就知道一路上经过的路由器地址和往返时间。
* NAT网络地址转换
   * NAT网络地址转换用来将本地IP转换为全球IP。
* 路由选择
路由器的功能是路由选择和分组转发。路由选择协议分为自治系统内部的路由选择(RIP,OSPF)和自治系统间(BGP)的路由选择。




