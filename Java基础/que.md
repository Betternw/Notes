1. 谈谈对java多态的理解？
   * 多态是指父类的某个方法被子类重写时，可以产生自己的功能行为，同一个操作作用于不同对象，可以有不同的解释，产生不同的执行结果。
   * 多态的三个必要条件： 继承父类。 重写父类的方法。 父类的引用指向子类对象。
   * 多态的定义：即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）
   * Java中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方法重载。
2. 说说你对Java反射的理解？
    * 反射首先是能够获取到Java中要反射类的字节码， 获取字节码有三种方法：
    * Class.forName(className)
    * 类名.class
    * this.getClass()
    * 将字节码中的方法，变量，构造函数等映射成相应的Method、Filed、Constructor等类，
3. 简单介绍一下java中的泛型，泛型擦除以及相关的概念，解析与分派？
    * 泛型的本质是参数化类型，也就是说所操的数据类型被指定为一个参数。
    * 泛型的好处是在编译的时候检查类型安全，并且所有的转换都是自动和隐式的，提高代码的重用率。
    * 泛型的参数类型可以使用extends语句，例如。习惯上称为“有界类型”。
    * 泛型的参数类型还可以是通配符类型。例如Class<?> classType = Class.forName("java.lang.String");
4. 泛型擦除以及相关的概念
    * 泛型信息只存在代码编译阶段，在进入JVM之前，与泛型关的信息都会被擦除掉。
    * 在类型擦除的时候，如果泛型类里的类型参数没有指定上限，则会被转成Object类型，如果指定了上限，则会被传转换成对应的类型上限。即保留类型参数的上限
    * 使用泛型的时候加上的类型参数，会在编译器在编译的时候擦除掉。生成的Java字节码中是不包含泛型中的类型信息的。这个过程就称为类型擦除。
5. 说说你对Java注解的理解？
    * 注解相当于一种标记，在程序中加了注解就等于为程序打上了某种标记。程序可以利用ava的反射机制来了解你的类及各种元素上有无何种标记，针对不同的标记，就去做相应的事件。标记可以加在包，类，字段，方法，方法的参数以及局部变量上。
    * Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。
6. Java的匿名内部类有哪些限制？
    * 只能继承一个父类或实现一个接口
    * Java中的匿名内部类不可以继承，只有内部类才可以有实现继承、实现接口的特性。而Kotlin是的匿名内部类是支持继承的，
    * 匿名内部类会默认持有外部类的引用，可能会导致内存泄漏。
7. NoClassDefFoundError 和 ClassNotFoundException 有什么区别？
    * ClassNotFoundException
      * 使用Class.forName方法来动态地加载类时，可以将类名作为参数传递给上述方法从而将指定类加载到JVM内存中，如果这个类在类路径中没有被找到，那么此时就会在运行时抛出ClassNotFoundException异常。————常见问题在于类名书写错误。
      * 当一个类已经某个类加载器加载到内存中了，此时另一个类加载器又尝试着动态地从同一个包中加载这个类。
   * NoClassDefFoundError 
     * JVM或者ClassLoader实例尝试加载（可以通过正常的方法调用，也可能是使用new来创建新的对象）类的时候却找不到类的定义。
     * 可能是打包过程漏掉了部分类，或者jar包出现损坏或者篡改。
     * 解决这个问题的办法是查找那些在开发期间存在于类路径下但在运行期间却不在类路径下的类。
8. String 为什么要设计成不可变的？
   * final修饰不可继承
   * 本质是char【】数组，没有修改char的方法
   * 保证了线程安全和字符串常量池的实现
9. 为什么Java里的匿名内部类只能访问final修饰的外部变量？
    * 如果变量不定义成final的，变量在匿名内部类被可以被修改，进而造成和外部的paramInteger不一致的问题，为了避免这种不一致的情况，因次Java规定匿名内部类只能访问final修饰的外部变量。
10. String，StringBuffer，StringBuilder有哪些不同？
    * String每次变化一个值就会开辟一个新的内存空间（final的）、StringBuilder：线程非安全的。StringBuffer：线程安全的
    * String底层用final char[ ]，不可变；StringBuffer和StringBuilder用char[]，可变。
    * String不可变，安全；StringBuffer加了同步锁，线程安全；StringBuilder是非线程安全的。
    * String改变时，生成新的String对象，将指针指向新的String；StringBuffer每次都对本身进行操作；StringBuilder速度会快一点。
    * 如果要操作少量的数据用 String。
    * 单线程操作字符串缓冲区下操作大量数据用 StringBuilder。
    * 多线程操作字符串缓冲区下操作大量数据用 StringBuffer。
    * "+"和"append"
      * 每一次 + 之前 都会new 一个StringBuilder对象，然后用append
      * 一般情况进行字符串拼接用+就可以，系统内部会进行优化，但是如果是循环拼接，则需要用StringBuilder的append来实现
      * 因为如果是循环拼接，那么系统会在循环体内部创建StringBUilder,这样会造成空间浪费；而用StringBuilder进行显示拼接时，可以定义在外面，减少内存的消耗
    * StringBuffer和StringBuilder都继承自AbstractStringBuilder这个类，而AbstractStringBuilder和String都继承自Object这个类
11. 什么是内部类？内部类的作用。
    * 内部类提供了更好的封装，除了该外围类，其他类都不能访问。
    * 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。
12. 父类的静态方法能否被子类重写？
    * 不能。
    * 子类继承父类后，用相同的静态方法和非静态方法，这时非静态方法覆盖父类中的方法（即方法重写）
    * 父类的该静态方法被隐藏（如果对象是父类则调用该隐藏的方法）。当父类引用指向子类对象，只会调用父类的静态方法。直接通过父类名.方法或变量名完成
    * java中静态属性和静态方法可以被继承，但是不可以被重写而是被隐藏。
13. 为什么复写equals方法的同时需要复写hashcode方法，前者相同后者是否相同，反过来呢？为什么？
    * equals：判断引用是否相等
    * 相等（相同）的对象必须具有相等的哈希码（或者散列码）。
    * 如果两个对象的hashCode相同，它们并不一定相同。
    * hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等。
    * 判断两个对象是否相等的规则是：
      * 判断两个对象的hashCode是否相等， 如果不相等，认为两个对象也不相等，完毕。如果相等，转入2
      * 判断两个对象用equals运算是否相等。如果不相等，认为两个对象也不相等。如果相等，认为两个对象相等。
14. java为什么跨平台？
    * 因为Java程序编译之后的代码不是能被硬件系统直接运行的代码，而是一种“中间码”——字节码。
    * 然后不同的硬件平台上安装有不同的Java虚拟机(JVM)，由JVM来把字节码再“翻译”成所对应的硬件平台能够执行的代码。
    * 因此对于Java编程者来说，不需要考虑硬件平台是什么。所以Java可以跨平台。
15. final，finally，finalize的区别？
    * final 可以用来修饰类、方法、变量，分别有不同的意义，final 修饰的 class 代表不可以继承扩展，final 的变量是不可以修改的，而 final 的方法也是不可以重写的（override）。
      * 被final修饰的变量，不可变的是变量的引用，而不是变量的内容
      * 用了map、list、数组、StringBuilder 、StringBuffer .它们的内容是可以修改的。但是不可以修改指向他们的引用
      * https://www.zhihu.com/question/20618891
    * finally 则是 Java 保证重点代码一定要被执行的一种机制。我们可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作。
    * finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收.比如关闭文件描述符（操作系统有限的资源）.
16. Java中对象的生命周期
    * 创建阶段(Created)
      * 加载class文件，执行静态变量和静态代码块
      * 对局部变量进行赋值（父、子）
      * new方法，构造函数。
      * 创建对象，为某些变量赋值。
    * 应用阶段(In Use)
      * 对象至少被一个强引用持有着
    * 不可见阶段(Invisible)：不再持有该对象的任何强引用
    * 不可达阶段(Unreachable)
      * 不再被任何强引用所持有
    * 收集阶段(Collected)
    * 终结阶段(Finalized)
    * 对象空间重分配阶段(De-allocated)
17. java中==和equals和hashCode的区别？
    * == ： 比较地址是否相同
    * equals： 内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。但我们可以重写equals方法，使其按照我们的需求的方式进行比较，如String类重写了equals方法，使其比较的是字符的序列，而不再是内存地址。
    * 判断两个对象是否相等的规则是：判断两个对象的hashCode是否相等。判断两个对象用equals运算是否相等。
18. Java的四种引用及使用场景？
    * 强引用（FinalReference）：在内存不足时不会被回收。平常用的最多的对象，如新创建的对象。
    * 软引用（SoftReference）：在内存不足时会被回收。用于实现内存敏感的高速缓存。
    * 弱引用（WeakReferenc）：只要GC回收器发现了它，就会将之回收。用于Map数据结构中，引用占用内存空间较大的对象。
    * 虚引用（PhantomReference）：在回收之前，会被放入ReferenceQueue，JVM不会自动将该referent字段值设置成null。其它引用被JVM回收之后才会被放入ReferenceQueue中。用于实现一个对象被回收之前做一些清理工作。
19. 类的加载过程，Person person = new Person();为例进行说明
    * .因为new用到了Person.class，所以会先找到Person.class文件，并加载到内存中;
    * 执行该类中的static代码块，如果有的话，给Person.class类进行初始化;
    * 在堆内存中开辟空间分配内存地址;
    * 在堆内存中建立对象的特有属性，并进行默认初始化;
    * 对属性进行显示初始化;
    * 对对象进行构造代码块初始化;
    * 对对象进行与之对应的构造函数进行初始化;
    * 将内存地址付给栈内存中的p变量。
20. JAVA常量池
    *  new Integer（123）：会新建一个对象。如果两个new出来的Integer对象，即使值相同，通过“==”比较结果为false，
    *  Integer.valueOf（123）：先判断值是否在缓存池中，如果存在，会使用缓存池中的对象，多次调用会取得同一个对象的引用。
    *  缓存池大小为-128~127
    *  当数值不在-128~127时，无论通过哪种方式，即使两对象的值相等，通过“==”比较，其结果为false；
21. 拆箱与装箱
    * Integer是int的包装类,int则是java的一种基本数据类型；
    * Integer变量必须实例化后才能使用,而int变量不需要；
    * Integer实际是对象的引用,当new一个Integer时,实际上是生成一个指针指向此对象;而int则是直接存储数据值 ；
    * Integer的默认值是null,int的默认值是0
    * 对于int，==比较的是值
    * 对于在-128—127的Integer，==比较的是值
    * 超出范围的Integer，==比较的是内存地址，需要用equals进行比较值
22. 抽象类与接口的区别：
    * 他们都不能被实例化，用于被其他类实现或继承。
    * 抽象类中可以有非抽象的方法，避免子类的重复书写，提高代码的复用
    * 接口只有抽象的方法，常量时静态属性。
    * 一个类只能继承一个抽象类，而一个类却可以实现多个接口；通过实现多个接口，能实现多继承的效果
    * 接口体现的是一种规范和实现分离的思想，充分利用接口，可以极好地降低程序各模块之间的耦合，从而提高系统的可扩展性和可维护性。接口相当于是一种规范，他制订了程序各模块需要遵循的标准，因此系统中的一个接口不应该经常改变，一旦接口改变，对整个系统的影响是辐射型的，导致系统大部分类都需要改写。
    * 接口是对行为的抽象
    * 抽象类作为系统中多个子类的父类，它体现的是一种模板式设计。抽象类作为多个子类的父类，可以被认为是一种中间产品，这种中间产品已经实现个部分功能，但是仍不能当成最终产品，需要进一步的完善，这种完善可以有几种不同的实现。
    * 抽象类是对类的抽象
23. 分别讲讲 final，static，synchronized 关键字可以修饰什么，以及修饰后的作用？
    * static：不依赖于任何对象就可以进行访问。静态变量在内存中只有一个副本，只有类初次加载时会被初始化。非静态变量在创建对象的时候被初始化，存在多个副本。
    * final：方法和类不能被重写和继承。变量值必须初始化且初始化后不能改变。final方法速度更快，因为在编译时已经静态绑定，不需要在运行时动态绑定。
    * synchronized：解决并发问题时的一种常用方法。确保线程互斥的访问同步代码、保证共享变量的修改能够及时可见、有效解决重排序问题。
24. equals”与“==”、“hashCode”的区别和使用场景
    * ==：基本类型比较数值、引用类型比较内存地址
    * equals：未重写时与==的作用相等。重写后：String比较的是值
    * hashCode：返回这个对象存储的内存地址的 hash　值。如果重写 equals() 方法必须要重写 hashCode() 方法。
    * equals()判断两个对象是否相等，hashCode()获取对象的哈希码，根据哈希码确定对象在哈希表中的索引。
25. = 的浅拷贝和深拷贝
    * 浅拷贝：基本数据类型进行值传递。引用数据类型将原对象的引用传递，指向的还是同一个对象。
    * 深拷贝：基本数据类型值传递。引用数据类型创建一个新的对象，并复试其内容。
26. 谈谈Error和Exception的区别？
    * Exception是java程序运行中可预料的异常情况，咱们可以获取到这种异常，并且对这种异常进行业务外的处理。
    * Error是java程序运行中不可预料的异常情况，这种异常发生以后，会直接导致JVM不可处理或者不可恢复的情况。所以这种异常不可能抓取到，比如OutOfMemoryError、NoClassDefFoundError等。
27. 什么是反射机制？反射机制的应用场景有哪些？
    * 反射是指：在运行过程中，对于任意一个类都能知道类的所有属性和方法。对于任何一个对象都能调用他的任意方法和属性
    * 动态获取和调用对象的属性和方法。
    * 流程
      * 获取class对象——Class.forName，getClass
      * newInstance获取class的实例
      * getFields,getConstructors,getMethods获取类成员
    * 任何一个类，在第一次使用时，就会被 JVM 加载到堆内存的方法区中。JVM 加载类成功后，就会在方法区中产生一个对应的 Class 对象（一个类只要一个 Class 对象），这个 Class 对象包含被加载类的全部结构信息。
    * 与注解相结合的框架：Retrofit
28. JDK、JRE和JVM
    * JDK(Java Development Kit)开发工具包，java开发环境的核心组件，提供编译调试和运行java程序所有的工具和文件。
    * JRE(Java Runtime Environment)java运行时环境，包括JVM和核心类库。
    * JVM(Java Virtual Machine)java虚拟机，Java程序运行在JVM上，将字节码转为机器码，提供内存管理、GC等功能。
29. 字节码
    * 字节码是Java源代码经过编译后生成的.class文件，只面向虚拟机。
    * Java源代码 -> 编译器 -> 字节码 -> JVM的解释器 -> 二进制代码 -> 程序运行
    * Java是先编译后解释执行的语言，不能单纯地归类。
30. Java和C++区别
    * 都是面向对象的语言，支持封装继承和多态
    * java没有指针访问内存
    * java类是单继承，C++多重继承
    * java有自动GC机制
    * C/C++中的字符串和数组都自动加一个’\0’作为结束符，java中不需要
31. 静态与非静态的区别
    * 静态只能访问静态的，非静态既能访问静态的也能访问非静态的
    * 静态的直接可以用类名调用，非静态的需要先实例化再调用。
    * 静态变量存在常量池中，非静态成员变量在堆中
    * 静态变量随类的加载而加载，消失而消失，非静态成员变量随对象创建而存在，消失而消失
    * synchronized修饰普通方法，锁的是this对象，同个类的两个对象访问结果不同
    * synchronized修饰静态方法，锁的是类，同个类的两个对象访问结果相同。
32. 注解：代替繁琐的配置文件
33. OOM
    * 内存溢出——分配的太少，用的太多，发生内存泄露，用完的没有被释放。
    * 堆内存溢出
      * 内存泄露——查找程序中的泄露代码
      * 堆大小设置不当——通过虚拟机参数-Xms,-Xmx等修改。初始内存时内存的1/64,最大内存时1/4.
    * 方法区溢出
    * 栈溢出（栈放的是方法）
      * 程序中存在死循环或者深度递归调用
        * 死循环：函数调用的参数是通过栈空间来传递的，在调用过程中会占用线程的栈资源。而递归调用，只有走到最后的结束点后函数才能依次退出，而未到达最后的结束点之前，占用的栈空间一直没有释放，如果递归调用次数过多，就可能导致占用的栈资源超过线程的最大值，从而导致栈溢出，导致程序的异常退出。
      * 栈大小设置太小——可以通过虚拟机参数-Xss来设置栈的大小。
34. 栈和堆
    * 栈中存放基本类型数据 a 10
    * 栈中存放堆的对象的引用，指针指向堆，堆中存放对象
35. String
    * final修饰的变量，是说引用地址不能改变。
```java
final int[] value = {1,2,3};
int []another = {4,5,6};
value = another;//报错。final不可变
value[2] = 100;//value = {1,2,100}
```
   * 构造方法创建的字符串，存储在堆中。String s1=new String("hello")
   * 直接赋值创建的字符串对象，存储在方法区的常量池中。String s2="hello"
   * 给一个已经创建的字符串重新赋值，栈中的引用会指向重新开辟的堆的内存空间
```java
        String a = new String("hello");
        String b = a;
        System.out.println("s1==s2:"+(a==b)); //true.b指向a
        a=null;
        System.out.println("s1==s2:"+(a==b)); // false,创建了新的a，b还指向原本的a
        System.out.println(b);
        System.out.println(a);
```
   * https://www.cnblogs.com/long-holiday/p/10246161.html