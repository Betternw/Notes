1. JVM内存区域。
    * 类加载器（ClassLoader）:在JVM启动时或者在类运行将需要的class加载到JVM中。
    * 执行引擎：负责执行class文件中包含的字节码指令；
    * 内存区（也叫运行时数据区）：是在JVM运行的时候操作所分配的内存区。
      * 方法区：用于存储类结构信息的地方，包括常量池、静态常量、构造函数等。方法区还包含一个运行时常量池。
      * 本地方法栈：和java栈的作用差不多，只不过是为JVM使用到native方法服务的。
      * 堆：存储java实例或者对象的地方。这块是GC的主要区域。从存储的内容我们可以很容易知道，方法和堆是被所有java线程共享的。
      * 栈：每当创一个线程时，JVM就会为这个线程创建一个对应的java栈。在这个java栈中,其中又会包含多个栈帧，每运行一个方法就建一个栈帧，用于存储局部变量表、操作栈、方法返回等。每一个方法从调用直至执行完成的过程，就对应一栈帧在java栈中入栈到出栈的过程。所以java栈是现成有的。
      * 程序计数器：用于保存当前线程执行的内存地址。由于JVM程序是多线程执行的（线程轮流切换），所以为了保证程切换回来后，还能恢复到原先状态，就需要一个独立计数器，记录之前中断的地方，可见程序计数器也是线程私有的。
2. 描述一下GC的原理和回收策略？
   * 引用类型
     * 强引用：代码中普遍存在的，只要强引用还存在，垃圾收集器就不会回收掉被引用的对象。
     * 软引用：SoftReference，用来描述还有用但是非必须的对象，当内存不足的时候会回收这类对象。
     * 弱引用：WeakReference，用来描述非必须对象，弱引用的对象只能生存到下一次GC发生时，当GC发生时，无论内存是否足够，都会回收该对象。
     * 虚引用：PhantomReference，它存在的唯一目的是在这个对象被回收时可以收到一个系统通知。
   * 如何判断强引用是否存在
     * 我们平时生成的Java对象，默认都是强引用，也就是说只要强引用还在，GC就不会回收，
     * 可达性分析算法
       * 通过一系列称为GCRoots的对象作为起始点，从这些节点从上向下搜索，所走过的路径称为引用链，当一个对象没有任何引用链与GCRoots连接时就说明此对象不可用，也就是对象不可达。
       * GC Roots对象通常包括：虚拟机栈中引用的对象（栈帧中的本地变量表）、方法中类的静态属性引用的对象、方法区中常量引用的对象、Native方法引用的对象
       * 第一次标记：对象在经过可达性分析后发现没有与GC Roots有引用链，则进行第一次标记并进行一次筛选，筛选条件是：该对象是否有必要执行finalize()方法。 如果有必要执行：则该对象会被放在一个F-Queue队列，并稍后在由虚拟机建立的低优先级Finalizer线程中触发该对象的finalize()方法，但不保证一定等待它执行结束，因为如果这个对象的finalize()方法发生了死循环或者执行时间较长的情况，会阻塞F-Queue队列里的其他对象，影响GC。
         * 当一个对象被虚拟机宣告死亡时会先调用它finalize()方法，让此对象处理它生前的最后事情（这个对象可以趁这个时机挣脱死亡的命运）
       * 第二次标记：GC对F-Queue队列里的对象进行第二次标记，如果在第二次标记时该对象又成功被引用，则会被移除即将回收的集合，否则会被回收。
   * 回收算法
     * 标记-清除：进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收。仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。
     * 标记-整理：标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。
     * 复制：复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这种算法适用于对象存活率低的场景，比如新生代。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况。
     * 分代收集算法：不同的对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的执行效率。当代商用虚拟机使用的都是分代收集算法：新生代对象存活率低，就采用复制算法；老年代存活率高，就用标记清除算法或者标记整理算法。
       * 新生代：
         * 所有新生成的对象首先都是放在新生代的。新生代的目标就是尽可能快速的收集掉那些生命周期短的对象。
         * 新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。
         * 当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。
         * 新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高
       * 老年代：
         * 在老年代中经历了N次垃圾回收后仍然存活的对象，就会被放到老年代中。因此，可以认为老年代中存放的都是一些生命周期较长的对象。
         * 内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC，即Full GC。Full GC发生频率比较低，老年代对象存活时间比较长。
       * 永久代：
         * 永久代主要存放静态文件，如Java类、方法等。
   * 内存分配和回收策略
     * 对象优先在Eden分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC。
     * 大对象直接进入老年代。如很长的字符串以及数组。很长的字符串以及数组。
     * 长期存活的对象将进入老年代。当对象在新生代中经历过一定次数（默认为15）的Minor GC后，就会被晋升到老年代中。
3. 类的加载器，双亲机制，Android的类加载器。
   * 类的加载器
     * 程序在启动的时候，并不会一次性加载程序所要用到的class文件，而是根据程序的需要，通过Java的类加载制（ClassLoader）来动态加载某个class文件到内存当的，从而只有class文件被载入到了内存之后，才能被其它class文件所引用。所以ClassLoader就是用来动态加载class件到内存当中用的。
     * 类加载机制：
       * 将类的class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，
       * 然后在堆区创建一个java.lang.Class对象，用来封装在方法区内的数据结构。
       * 类的加载最终是在堆区内的Class对象，
       * Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。
     * 类加载方式
       * 命令行启动应用时候由JVM初始化加载
       * 通过Class.forName（）方法动态加载
       * 通过ClassLoader.loadClass（）方法动态加载
     * 虚拟机通过一个类的全限定名来获取描述此类的二进制字节流，，而完成这个加载动作的就是类加载器。
     * 类加载器可以分为三类：启动类、扩展类、应用类
   * 双亲机制
     * 原理：
       * 当一个ClassLoader实例需要加载某个类时，首先由最顶层的类加载器启动类加载器试图加载，如果没加载到，则把任务转交给扩展类加载器试图加载，如果也没加载到，则转交给应用类加载器进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等待URL中加载该类。
     * 工作流程
       * 如果一个类加载器收到了加载类的请求，它不会自己立去加载类，它会先去请求父类加载器，每个层次的类加器都是如此。层层传递，直到传递到最高层的类加载器只有当 父类加载器反馈自己无法加载这个类，才会有当子类加载器去加载该类。
     * 原因：避免重复加载，当父类已经加载了该类的时候，就没有必要让子类再加载一次。
   * JVM在搜索类的时候，又是如何判定两个class是相同的呢？：不仅类名相同，还要判断是否由同一个类加载器实例加载的。