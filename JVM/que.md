1. JVM内存区域。
    * 类加载器（ClassLoader）:在JVM启动时或者在类运行将需要的class加载到JVM中。
    * 执行引擎：负责执行class文件中包含的字节码指令；
    * 内存区（也叫运行时数据区）：是在JVM运行的时候操作所分配的内存区。
      * 方法区：用于存储类结构信息的地方，包括常量池、静态常量、构造函数等。方法区还包含一个运行时常量池。
      * 本地方法栈：和java栈的作用差不多，只不过是为JVM使用到native方法服务的。
      * 堆：存储java实例或者对象的地方。这块是GC的主要区域。从存储的内容我们可以很容易知道，方法和堆是被所有java线程共享的。
      * 栈：每当创一个线程时，JVM就会为这个线程创建一个对应的java栈。在这个java栈中,其中又会包含多个栈帧，每运行一个方法就建一个栈帧，用于存储局部变量表、操作栈、方法返回等。每一个方法从调用直至执行完成的过程，就对应一栈帧在java栈中入栈到出栈的过程。所以java栈是现成有的。
      * 程序计数器：程序计数器其实就是一个指针，指向程序中下一句要执行的指令。字节码解释器通过改变程序计数器来选取下一条需要执行的字节码指令，多线程时程序计数器用来记录当前线程执行位置，方便多线程切换。其随线程创建而创建，消亡而消亡。
    * 本地接口
    * 流程
      * 类加载器将类的class文件加载到jvm中
      * 内存区将字节码文件加载到内存中
      * 执行引擎将字节码翻译成底层系统指令，交给cpu执行
      * 这中间的过程需要本地接口实现功能
2. 描述一下GC的原理和回收策略？
   * 判断对象是否需要被回收：引用计数法、可达性分析、对象的引用类型、废弃常量与无用类
   * 引用类型
     * 强引用：代码中普遍存在的，只要强引用还存在，垃圾收集器就不会回收掉被引用的对象。我们平时生成的Java对象，默认都是强引用，也就是说只要强引用还在，GC就不会回收，
     * 软引用：SoftReference，用来描述还有用但是非必须的对象，当内存不足的时候会回收这类对象。
     * 弱引用：WeakReference，可有可无，每次只要GC就会回收弱引用，不管内存够不够都回收
     * 虚引用：PhantomReference，主要是当对象被回收时有一个系统通知。
   * 引用计数法
       * 为对象添加一个引用计数器，被引用一次，计数器加1，引用失效，计数器减1，当计数器为0，进行GC。
       * 无法解决两个变量循环引用的问题。eg. A和B相互引用，计数器一直++，不为0。
   * 可达性分析算法
       * 通过一系列称为GCRoots的对象作为起始点，从这些节点从上向下搜索，所走过的路径称为引用链，当一个对象没有任何引用链与GCRoots连接时就说明此对象不可用，也就是对象不可达。
       * GC Roots对象通常包括：虚拟机栈中引用的对象（栈帧中的本地变量表）、方法中类的静态属性引用的对象、方法区中常量引用的对象、Native方法引用的对象
       * 第一次标记：对象在经过可达性分析后发现没有与GC Roots有引用链，则进行第一次标记并进行一次筛选，筛选条件是：该对象是否有必要执行finalize()方法。 如果有必要执行：则该对象会被放在一个F-Queue队列，并稍后在由虚拟机建立的低优先级Finalizer线程中触发该对象的finalize()方法，但不保证一定等待它执行结束，因为如果这个对象的finalize()方法发生了死循环或者执行时间较长的情况，会阻塞F-Queue队列里的其他对象，影响GC。
         * 当一个对象被虚拟机宣告死亡时会先调用它finalize()方法，让此对象处理它生前的最后事情（这个对象可以趁这个时机挣脱死亡的命运）
       * 第二次标记：GC对F-Queue队列里的对象进行第二次标记，如果在第二次标记时该对象又成功被引用，则会被移除即将回收的集合，否则会被回收。
   * 废弃常量和无用类
     * 常量池回收废弃常量：当前没有任何对象引用常量
     * 方法区回收无用类：类的实例被回收、classLoder被回收、类的对象没有任何引用和访问
   * 回收算法
     * 标记-清除：标记阶段，标记出所有需要被回收的对象；清除阶段，遍历整个堆，清除被标记对象。仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。
     * 标记-整理：标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。
     * 复制：复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这种算法适用于对象存活率低的场景，比如新生代。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况。
     * 分代收集算法：不同的对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的执行效率。当代商用虚拟机使用的都是分代收集算法：新生代对象存活率低，就采用复制算法；老年代存活率高，就用标记清除算法或者标记整理算法。
       * 新生代：
         * 所有新生成的对象首先都是放在新生代的。新生代的目标就是尽可能快速的收集掉那些生命周期短的对象。
         * 新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。
         * 当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。
         * 新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高
         * 为什么设置了eden区还要设置survivor区？
           * 没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。
           * Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。
         * 为什么要设置两个survivor区
           * 空间利用率问题：只有一个survivor的话，如果是8比2，多次gc后s区的剩余空间很容易满，如果是1比1，一半闲置，空间利用率低。但是如果 Survivor 分区有 2 个分区，我们就可以把 Eden、From Survivor、To Survivor 分区内存比例设置为 8:1:1 ，那么任何时候新生代内存的利用率都 90% ，这样空间利用率基本是符合预期的。
           * 内存碎片化问题：在发生多次的gc时，一个s区本身的存活对象和从eden区中复制来的存活对象，会造成内存碎片。而两个s区，永远有一个survivor space是空的，另一个非空的survivor space无碎片。（采用的复制算法会保证S1中来自S0和Eden两部分的存活对象占用连续的内存空间）
           * https://blog.csdn.net/antony9118/article/details/51425581
         * 为什么不能多个？
           * 如果Survivor区再细分下去，每一块的空间就会比较小，很容易导致Survivor区满，
       * 老年代：
         * 在老年代中经历了N次垃圾回收后仍然存活的对象，就会被放到老年代中。因此，可以认为老年代中存放的都是一些生命周期较长的对象。
         * 内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC，即Full GC。Full GC发生频率比较低，老年代对象存活时间比较长。
       * 永久代：
         * 永久代主要存放静态文件，如Java类、方法等。
   * 为什么要进行新生代和老年代的区分——不同对象的生命周期不同，根据生命周期采取不同的回收策略，提高回收效率
   * 内存分配和回收策略
     * 对象优先在Eden分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC。
     * 大对象直接进入老年代。如很长的字符串以及数组。很长的字符串以及数组。
     * 长期存活的对象将进入老年代。当对象在新生代中经历过一定次数（默认为15）的Minor GC后，就会被晋升到老年代中。
   * 垃圾回收器
     * 新生代：ParNew收集器，串行收集器的多线程版本。新生代是并行，老年代是串行
     * 老年代：CMS收集器，标记清除算法和partnew一起使用
       * 初始标记：stop the world，标记gc root直接关联的对象
       * 并发标记：同时开启gc和用户线程，记录可达对象和引用更新
       * 重新标记：stop the world，重新并发标记因用户程序运行而导致变动的对象标记记录
       * 并发清除：开启用户线程，基于标记清除对象
       * 优点：停顿时间少，并发收集
       * 缺点：无法处理浮动垃圾。浮动垃圾指在GC完成时产生的垃圾，这些垃圾只能在下一GC周期回收；标记清除方式会产生内存碎片。
     * G1收集器——整堆
       * 将堆划分为多个等大小的区域
       * 将 GC 分为几个阶段；
       * 对于不同的生命周期对象采用不同的收集方式
       * 维护一个垃圾价值优先列表，根据停顿时间从表中选择价值最大的区域回收。
       * 特点
         * 并行和并发：充分利用CPU和多核环境，缩短Stop the World的时间。
         * 分代收集：不用其他收集器就可管理整个GC，且保留了分代；
         * 空间整合：整体上是标记-整理算法，局部上是复制算法；
         * 可预测的停顿：能让用户明确指定停顿时间长度，来进行GC。
3. 类的加载器，双亲机制，Android的类加载器。
   * 类的加载器
     * 程序在启动的时候，并不会一次性加载程序所要用到的class文件，而是根据程序的需要，通过Java的类加载制（ClassLoader）来动态加载某个class文件到内存当的，从而只有class文件被载入到了内存之后，才能被其它class文件所引用。所以ClassLoader就是用来动态加载class件到内存当中用的。
   * 类加载机制：加载、验证、准备、解析、初始化
     * 加载
       * 将类的class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，
       * 然后在堆区创建一个java.lang.Class对象，用来封装在方法区内的数据结构。
       * 类的加载最终是在堆区内的Class对象，
       * Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。
     * 验证——确保被加载类的正确性，比如字节码验证、文件格式验证
     * 准备——为静态变量分配内存、初始化为默认值。public static int value=3，初始值是0；public static final int value=3，初始值为3。
     * 解析——将符号引用转换为直接引用。符号引用是说用符号来描述引用的目标，直接引用就是直接指向内存的地址。
     * 初始化——为变量赋初始值
   * 类加载方式
       * 命令行启动应用时候由JVM初始化加载
       * 通过Class.forName（）方法动态加载
       * 通过ClassLoader.loadClass（）方法动态加载
   * 虚拟机通过一个类的全限定名来获取描述此类的二进制字节流，，而完成这个加载动作的就是类加载器。
   * 类加载器可以分为三类：启动类、扩展类、应用类
   * 双亲机制
     * 原理：
       * 当一个ClassLoader实例需要加载某个类时，首先由最顶层的类加载器启动类加载器试图加载，如果没加载到，则把任务转交给扩展类加载器试图加载，如果也没加载到，则转交给应用类加载器进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等待URL中加载该类。
     * 工作流程
       * 如果一个类加载器收到了加载类的请求，它不会自己立去加载类，它会先去请求父类加载器，每个层次的类加器都是如此。层层传递，直到传递到最高层的类加载器只有当 父类加载器反馈自己无法加载这个类，才会有当子类加载器去加载该类。
     * 原因：避免重复加载，当父类已经加载了该类的时候，就没有必要让子类再加载一次。
   * JVM在搜索类的时候，又是如何判定两个class是相同的呢？：不仅类名相同，还要判断是否由同一个类加载器实例加载的。
4. 深拷贝和浅拷贝
* 浅拷贝：增加一个指针，指向已经存在的内存地址
* 深拷贝：增加一个指针和内存区域，指针指向新的内存地址
5. 对象创建的过程
* 类加载检查——new 指令时，先在常量池中检查是否已经存在这个类的符号引用，检查是否被加载解析过，如果没有就进行类加载
* 分配内存——在堆中划分内存
   * 内存分配方式
     * 指针碰撞：堆中没有内存碎片，将用过的内存放在一边，没有用过的放在另一边，中间有一个分界指针，内存分配时指针向没用过内存的方向移动。
     * 空闲列表：堆中有内存碎片，虚拟机维护一个列表记录可用的内存块，然后划分一块足够大的空闲块给对象
   * 内存分配的线程安全
     * CAS+失败重试：假设没有冲突去完成某个操作，若有冲突而失败则不断重试直到成功。保证操作原子性。
     * TLAB：为每一个线程都分配一块内存，每次分配内存时，先在TLAB(Thread Local Allocation Buffer)中分配，不够时再用第一种方法。
* 初始化零值——将划分的内存初始化零值， 保证不赋值也可以使用
* 设置对象头——对对象进行设置，将信息放在对象头中，比如哈希码、年代年龄等
* 执行init方法——jvm中对象新建完成，在程序中执行init（）方法。
6. java内存泄露
* 概念
  * 存在一些不能被GC回收，仍然占用内存的对象
* 原因
  * 长生命周期的对象持有短生命周期对象的引用，导致短生命周期的对象无法被回收。
* 情况举例
  * 单例模式持有外部引用
  * 各种连接比如数据库链接、socket连接没有关闭
  * 监听器，删除对象时没有删除监听器
* 解决方案
  * 少用static，减少生命周期长度
  * 不用的对象手动置为null
  * 用完就关闭close
7. 各种流程
  * jvm操作流程
    * 类加载器将class文件加载到jvm中
    * 方法区将字节码文件加载到内存中
    * 执行引擎将字节码翻译成底层系统指令，交给cpu执行
    * 这期间要调用本地接口实现功能
  * java创建对象的过程
    * 类加载检查——new时，先检查能否在常量池中定位到这个类的引用，以及是否被加载过，如果没有就进行类加载
    * 分配内存
    * 初始化零值——将内存空间分配零值
    * 设置对象头——比如GC年龄，哈希对象码等
    * 执行init方法——对象新建完毕，程序执行init方法
  * 类加载流程
    * 加载
      * 将类的class文件转二进制数据加载到内存中，保存在方法区内
      * 在堆上创建对象，封装方法区内的数据结构
    * 验证——确保被加载类的正确性，比如文件格式验证、字节码验证
    * 准备——为类的静态变量分配内存并初始化为默认值
    * 解析——将符号引用转为直接引用，符号引用使用符号来描述引用的目标，直接引用就是直接指向引用的地址
    * 初始化——赋值，为变量赋予正确的初始值
8. minor gc运行的很频繁，可能是什么原因——堆内存太小
9. 类的加载顺序：父类静态语句——子类静态语句——父类非静态语句——父类构造函数——子类非静态语句——子类构造函数