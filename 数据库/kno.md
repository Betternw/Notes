# MySql
## 一 索引
#### B+Tree原理
1. 数据结构
* 平衡树查找树，叶子节点位于同一层
* B Tree+叶子节点顺序访问
* 一个节点中的key从左至右非递减序列
2. 操作
* 在根节点进行二分查找，找到一个key所在的指针
* 递归在指针指向的节点进行查找
* 直到查找到叶子节点，然后在叶子节点上进行二分查找
* 插入删除会破坏平衡性，因此在插入删除之后，需要对树进行分裂、合并、旋转等操作来维护平衡
3. 与红黑树的比较
* B+ 树有更低的树高。平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多
* 磁盘访问原理：索引的一个节点设置为一页的大小，B+树的树高更低，寻道次数更低，在访问磁盘时需要很短的磁盘旋转时间
* 磁盘预读特性：预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快
#### MySQL索引
在存储引擎层实现
1. B+树索引——大多数引擎
* mysql的默认索引类型
* 查找、排序、分组
* 主索引的叶子叶子节点存放着完整的数据记录——聚簇索引
* 辅助索引的叶子节点data域记录主键的值
2. 哈希索引
* o（1）查找时间
* 无法用于排序和分组
* 当某个索引被使用的非常频繁，会在b+树上创建一个哈希索引——InnoDB
3. 全文索引——MyISAM InnoDB
* 查找文本中的关键词
* 倒排索引实现，记录关键词到所在文档的映射
4. 空间数据索引
* 从所有维度来索引数据，可以使用任意维度进行组合查询
#### 索引优化
1. 独立的列：查询时索引列不嗯呢该事表达式的一部分也不能是函数的参数
2. 多列索引：比多个单列索引性能好
3. 索引列的顺序：不重复的索引值和记录总数的比值——索引的选择性，选择性越高，区分度越高，查询效率越高，查询顺序越靠前
4. 前缀索引：BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符
5. 覆盖索引：索引包含所有需要查询的字段的值。
6. 索引优点：减少了服务器需要扫描的数据行数，将随机IO变为顺序IO
7. 索引的使用条件：中到大型的表

## 二 查询性能优化
#### 使用Explain进行分析
Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句
#### 优化数据访问
1. 减少请求的数据量——只返回必要的行、列，缓存重复查询的数据
2. 减少服务器端扫描的行数——使用索引覆盖查询

#### 重构查询方式
1. 切分大查询——一次性执行大查询，会锁住很多数据
2. 分界大连接查询——将一个大查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联。能够让缓存更高效、减少冗余记录的查询、提高查询效率

## 三 存储引擎
#### InnoDB
1. 默认事务性存储引擎
2. 实现的隔离级别：可重复读，MVCC+NEXT-KEY locking实现幻影读
3. 主索引是聚簇索引，在索引中保存数据，避免直接读取磁盘
4. 内部优化：可预测性读、自适应哈希索引
5. 支持在线热备份（读取视图时不需要停止对其他表的写入）

#### MyISAM
1. 不支持事务和行级锁，只对整张表加锁
2. 读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入
3.  DELAY_KEY_WRITE：修改完成后不会立即写入磁盘，而是写入缓冲区，在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘

#### 比较

* 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
* 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
* 外键：InnoDB 支持外键。
* 备份：InnoDB 支持在线热备份。崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
* 其它特性：MyISAM 支持压缩表和空间数据索引。

## 四 数据类型
TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好
FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型
CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的
DATETIME能够保存从 1000 年到 9999 年的日期和时间，精度为秒
TIMESTAMP和时区有关，一个时间戳在不同的时区所代表的具体时间是不同的

## 五 切分
1. 水平切分：将同一个表中的记录拆分到多个结构相同的表中
2. 垂直切分：一张表按列切分成多个表
3. 切分策略：哈希取模、id或者时间范围、映射表
4. 切分存在的问题：事务问题、连接、id唯一性

## 六 复制
1. 主从复制
* binlong线程：将主服务器上的数据更改写入二进制日志中
* IO线程：从主服务器上读取二进制日志，并写入从服务器的中继日志
* sql线程：读取中继日志，解析出主服务器已经执行的数据更改并在从服务器重放
2. 读写分离
* 主服务器处理写操作和实时性要求比较高的操作，从服务器处理读操作
* 常用代理方式实现，代理服务器接收应用层传来的读写请求然后决定转发到哪个服务器

# SQL
1. 主键的值不允许修改
2. 数据库创建：CREATE DATABASE test;
3. 创建表：CREATE TABLE mytable
4. 修改表：
ALTER TABLE mytable

* ADD col CHAR(20);
* DROP COLUMN col;
* DROP TABLE mytable;
5. 插入：
* 普通插入
INSERT INTO mytable(col1, col2)
VALUES(val1, val2);
* 插入检索出来的数据
INSERT INTO mytable1(col1, col2)
SELECT col1, col2
FROM mytable2;
* 将一个表的内容插入到一个新表
CREATE TABLE newtable ASSELECT * FROM mytable;
6. 更新：
UPDATE mytable
SET col = val
WHERE id = 1;
7. 删除
* DELETE FROM mytable WHERE id = 1;
* Truncate TABLE mytable;清空表
8. 查询
* Distinct
SELECT DISTINCT col1, col2
FROM mytable;
* Limit——限制返回的行数。第一个参数为起始行，第二个参数为返回的总行数
返回前 5 行：
SELECT *FROM mytable
LIMIT 0, 5;

9. 排序：Asc 升序（默认） Dsc降序
SELECT *FROM mytable
ORDER BY col1 DESC, col2 ASC;

10. 过滤
* 用where进行筛选
* and和or可以连接多个过滤条件
* IN用于匹配一组值
* Not用于否定一个条件

11. 通配符
* % 匹配 >=0 个任意字符
* _ 匹配 ==1 个任意字符
* [ ] 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符
* 使用 Like 来进行通配符匹配
12. 计算字段
* 使用 AS 来取别名
SELECT col1 * col2 AS alias
FROM mytable
* CONCAT() 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 TRIM() 可以去除首尾空格
SELECT CONCAT(TRIM(col1), '(', TRIM(col2), ')') AS concat_col
FROM mytable
13. 函数: 
* 汇总：avg——平均值，conunt——某列的行数，max——某列的最大值，min——某列的最小值，sum——某列值之和，distinct——汇总不同的值
* 文本处理：
 SOUNDEX() 可以将一个字符串转换为描述其语音表示的字母数字模式
* 日期和时间
* 数值
14. 分组：
* group by——自动按分组字段进行排序（不仅分组，还排序）。order by——按汇总字段进行排序
* where过滤行。having过滤分组。
* GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前
* NULL 的行会单独分为一组；
15. 子查询——返回一个字段的数据
16. 连接：多个表之间，使用join和on
* 内连接——使用Inner join
SELECT A.value, B.valueFROM tablea AS A INNER JOIN tableb AS B
ON A.key = B.key;
* 自连接：连接自身
* 自身连接：自动连接同名列——NATURAL JOIN，而内连接需要提供连接的列
* 外连接——保留没有关联的行。左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行
17. 组合查询
* UNION，多个查询
* 每个查询必须包含相同的列、表达式和聚集函数
* 如果需要保留相同行，使用 UNION ALL
18. 视图
* 虚拟表，不包含数据，不能进行索引操作
* 简化操作，只使用表的一部分数据，只给用户访问的权限
19. 存储过程
* 对一系列sql操作的批处理
* 命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误
* 包含 in、out 和 inout 三种参数。
* 给变量赋值都需要用 select into 语句。
* 每次只能给一个变量赋值，不支持集合的操作。
20. 游标
* 使用游标对一个结果集进行遍历
* 声明游标——打开游标——取出游标——关闭游标
21. 触发器
* 在执行delete、insert、update时自动执行
* 触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中
* INSERT 触发器包含一个名为 NEW 的虚拟表
* DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。
* UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。
22. 事务管理
* 不能回退select、create和drop语句
* 默认隐式提交，将一条语句当做事务进行提交
* 出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交
* 设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的
23. 字符集
* 字符集为字母和符号的集合；
* 编码为某个字符集成员的内部表示；
* 校对字符指定如何比较，主要用于排序和分组。
24. 权限管理
* 创建账户——新创建的账户没有任何权限。CREATE 
* 修改账户名——RENAME 
* 删除账户——DROP
* 查看权限——SHOW GRANTS 
* 授予权限账户用 username@host 的形式定义，username@% 使用的是默认主机名。GRANT SELECT, INSERT ON mydatabase.* TO myuser;
* 删除权限GRANT 和 REVOKE 可在几个层次上控制访问权限：整个服务器——GRANT ALL 和 REVOKE ALL；整个数据库——ON database.* ；特定的表—— ON database.table；特定的列——特定的存储过程。
* 更改密码必须使用 Password() 函数进行加密。SET PASSWROD FOR myuser = Password('new_password');

# 数据库
## 1. 事物
#### 概念
1. 事物：满足ACID的一组操作。
2. 通过Commit提交事物，使用rollback进行回滚

#### ACID
1. 原子性：事物是不可分割的最小单元
2. 一致性：事物执行前后保持一致
3. 隔离性：提交前其他事物不可见
4. 持久性：即使系统崩溃结果也不会丢失。使用重做日志进行恢复。
5. 无并发——满足隔离性——需要满足原子性，才能满足一致性——执行结果正确
6. 并发——需要满足原子性和隔离性，才能满足一致性——执行结果正确
7. 持久性——应对系统崩溃

#### Autocommit
自动提交模式

## 二 并发一致性
并发需要满足原子性和隔离性，才能满足一致性，保证结果正确。但是隔离性很难满足。
会造成的问题：
1.  丢失修改：两个事物对数据进行修改，一个事物的更新操作被另一个覆盖
2. 读脏数据：读到未提交的数据，但是这个数据被撤销，那么这个数据就是脏数据
3. 不可重复读：不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致
4. 幻影读：本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

## 三 封锁
1. 并发控制来保证隔离性
2. 并发控制通过封锁实现
3. 封锁需要用户自己控制
#### 封锁粒度
1. 应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高
#### 读写锁
1. 读写锁
* 互斥锁（Exclusive），简写为 X 锁，又称写锁。
* 共享锁（Shared），简写为 S 锁，又称读锁
* 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁
* 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁
2. 意向锁
* 意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁
* 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁
* 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁

#### 封锁协议
1. 三级封锁协议
* 一级封锁协议：事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁——解决丢失修改
* 二级封锁协议：一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁——解决读脏数据
* 三级封锁协议：在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁——避免不可重复读
2. 两端锁协议
* 加锁和解锁分为两个阶段进行
* 可串行化调度：通过并发控制，使并发执行的事务结果与某个串行执行的事务结果相同。
#### MySql隐式和显示锁定
1. MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定
2. InnoDB 也可以使用特定的语句进行显示锁定：SELECT ... LOCK In SHARE MODE;
SELECT ... FOR UPDATE;

## 四 隔离级别
1. 未提交读：事务中的修改，即使没有提交，对其他事务也是可见的——RU：脏读
2. 不可重复读：一个事务所做的修改在提交之前对其它事务是不可见的。——RC：在console B没有提交数据修改的commit的时候，console A是读不到修改后的数据的，这就避免了在RU模式中的脏读，但是有一个问题我们会发现，在console A同一个事务中。两次select的数据不一样，这就存在了不可重复读的问题.PS：RC事务隔离级别是Oracle数据库的默认隔离级别.
3. 可重复读：保证在同一个事务中多次读取同一数据的结果是一样的——RR：在RR级别中，我们解决了不可重复读的问题，即在这种隔离级别下，在一个事务中我们能够保证能够获取到一样的数据（即使已经有其他事务修改了我们的数据）。但是无法避免幻读，幻读简单的解释就是在数据有新增的时候，也无法保证两次得到的数据不一致，但是不同数据库对不同的RR级别有不同的实现，有时候或加上间隙锁来避免幻读。在MySQL可重复读的隔离级别中并不是完全解决了幻读的问题，而是解决了读数据情况下的幻读问题。而对于修改的操作依旧存在幻读问题，就是说MVCC对于幻读的解决时不彻底的。 通过索引加锁，间隙锁，next key lock可以解决幻读的问题。
4. 可串行化：强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题——S

## 五 多版本并发控制
1. MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式
2. 用于实现提交读和可重复读这两种隔离级别
#### 基本思想
1. 写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系
2. MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照

#### 版本号
* 系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
* 事务版本号 TRX_ID ：事务开始时的系统版本号。

#### Undo日志
1. MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来
2. INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1
3.  undoLog 也就是我们常说的回滚日志文件 主要用于事务中执行失败，进行回滚，以及MVCC中对于数据历史版本的查看。由引擎层的InnoDB引擎实现,是逻辑日志,记录数据修改被修改前的值,
4. 比如"把id='B' 修改为id = 'B2' ，那么undo日志就会用来存放id ='B'的记录”。当一条数据需要更新前,会先把修改前的记录存储在undolog中,如果这个修改出现异常,,则会使用undo日志来实现回滚操作,保证事务的一致性。当事务提交之后，undo log并不能立马被删除,而是会被放到待清理链表中,待判断没有事物用到该版本的信息时才可以清理相应undolog。它保存了事务发生之前的数据的一个版本，用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。

#### ReadView
1. 包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, ...}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX
2. 在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用
3. undoLog 也就是我们常说的回滚日志文件 主要用于事务中执行失败，进行回滚，以及MVCC中对于数据历史版本的查看。由引擎层的InnoDB引擎实现,是逻辑日志,记录数据修改被修改前的值,
4. 比如"把id='B' 修改为id = 'B2' ，那么undo日志就会用来存放id ='B'的记录”。当一条数据需要更新前,会先把修改前的记录存储在undolog中,如果这个修改出现异常,,则会使用undo日志来实现回滚操作,保证事务的一致性。当事务提交之后，undo log并不能立马被删除,而是会被放到待清理链表中,待判断没有事物用到该版本的信息时才可以清理相应undolog。它保存了事务发生之前的数据的一个版本，用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。

#### 快照读和当前读
1.  快照读：MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作
2.  当前读；会对于要对数据库进行修改的操作进行加锁操作，

## 六 Next-keys Locks
InnoDB存储引擎的一种锁实现。MVCC加Next-Key locks可以解决幻读问题
1. Record Locks：锁定一个记录上的索引，而不是记录本身。如果没有索引会自动在主键上创建隐藏的索引。
2. Gap Locks：锁定索引之间的间隙，但是不包括索引本身。
3. Next-Key Locks：上面两个锁的集合，不仅锁定索引还锁定间隙。

## 七 关系数据库设计理论
#### 函数依赖
1.  A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A
2.  键码：一个集合，包括集合的一个或者多个属性，这个集合决定了关系的其他所有属性并且是最小的
3.  部分函数依赖：A的真子集决定B 
4.  完全函数依赖：没有A的真子集决定B，A的整个集合决定B

#### 异常
1. 冗余数据
2. 修改异常
3. 删除异常
4. 插入异常

#### 范式
为了解决异常。高级别低的范式依赖于低级别的范式。

1. 1NF：属性不可分
2. 2NF：每个非主属性完全依赖于键码
3. 3NF：非主属性不传递函数依赖于键码（没有传递依赖）

## 八 ER图

三个组成部分：实体、属性、联系
1. 实体的三种联系：一对一 一对多 多对多
2. 联系具有多向性